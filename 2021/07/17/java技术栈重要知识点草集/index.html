<!DOCTYPE html>
<html lang=zh>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <meta name="google-site-verification" content="29vLVh4vA4suQh5SRMCfQisJ8UugXBkjM46VFkYeonU">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000">
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top">

  <!--  -->

  
  <title>java技术栈重要知识点草集 | Hexo</title>
  <meta name="description" content="javajvmjvm内存区域程序计数器、堆、栈、本地方法栈、方法区 jvm多线程并发创建对象解决方案 cas+失败重试 每个线程留出一块内存：本地线程分配缓存(Thread Local Allocation Buffer - TLAB)  内存回收(gc) - 方法论垃圾收集算法      对应垃圾收集算法        分代  标记 - 清除   CMS                  年老代">
<meta name="keywords" content="java技术栈">
<meta property="og:type" content="article">
<meta property="og:title" content="java技术栈重要知识点草集">
<meta property="og:url" content="https://yaoyuanyy.github.io/2021/07/17/java技术栈重要知识点草集/index.html">
<meta property="og:site_name" content="skyler-blog">
<meta property="og:description" content="javajvmjvm内存区域程序计数器、堆、栈、本地方法栈、方法区 jvm多线程并发创建对象解决方案 cas+失败重试 每个线程留出一块内存：本地线程分配缓存(Thread Local Allocation Buffer - TLAB)  内存回收(gc) - 方法论垃圾收集算法      对应垃圾收集算法        分代  标记 - 清除   CMS                  年老代">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20220320172640.png">
<meta property="og:image" content="https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20210818232422.png">
<meta property="og:image" content="https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20210819001418.png">
<meta property="og:image" content="https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20220601202445.png">
<meta property="og:image" content="https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20221107174822.png">
<meta property="og:image" content="https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20221110174626.png">
<meta property="og:image" content="https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20221112181145.png">
<meta property="og:image" content="https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20221209200402.png">
<meta property="og:image" content="https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20221209200126.png">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-cfe4e7eb1070a77fdc24e23c639b6e9c_1440w.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20230310110434.png">
<meta property="og:image" content="https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20210817104325.png">
<meta property="og:image" content="https://cdn.learnku.com/uploads/images/202012/15/64262/RgOhomEvtg.webp!large">
<meta property="og:updated_time" content="2025-11-15T04:49:10.272Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java技术栈重要知识点草集">
<meta name="twitter:description" content="javajvmjvm内存区域程序计数器、堆、栈、本地方法栈、方法区 jvm多线程并发创建对象解决方案 cas+失败重试 每个线程留出一块内存：本地线程分配缓存(Thread Local Allocation Buffer - TLAB)  内存回收(gc) - 方法论垃圾收集算法      对应垃圾收集算法        分代  标记 - 清除   CMS                  年老代">
<meta name="twitter:image" content="https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20220320172640.png">
  <!-- Canonical links -->
  <link rel="canonical" href="https://yaoyuanyy.github.io/2021/07/17/java技术栈重要知识点草集/index.html">
  
    <link rel="alternate" href="/atom.xml" title="skyler-blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  <link rel="stylesheet" href="/css/style.css">
  
  
  
  
</head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope="" itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/yaoyuanyy" target="_blank">
          <img class="img-circle img-rotate" src="/images/meinv.jpeg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">skyler</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Web Developer</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> beijing, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索">
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech="">
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope="" itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-books">
          <a href="/books">
            
            <i class="icon icon-book-fill"></i>
            
            <span class="menu-title">书单</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">友链</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/yaoyuanyy" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li>
        
        <li><a href="https://juejin.cn/user/729731449759047/posts" target="_blank" title="Juejin" data-toggle="tooltip" data-placement="top"><i class="icon icon-juejin"></i></a></li>
        
        <li><a href="https://blog.csdn.net/mingliangniwo" target="_blank" title="Csdn" data-toggle="tooltip" data-placement="top"><i class="icon icon-csdn"></i></a></li>
        
        <li><a href="https://yaoyuanyy.github.io" target="_blank" title="Github Pages" data-toggle="tooltip" data-placement="top"><i class="icon icon-github pages"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope="" itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AI/">AI</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a><span class="category-list-count">4</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/docker/centos7/">centos7</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/centos8/">centos8</a><span class="category-list-count">3</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/http/">http</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/http/javaweb/">javaweb</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">14</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/java/agent/">agent</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/jvm/">jvm</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/spring/">spring</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/java-io/">java io</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java基础/">java基础</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java多线程/">java多线程</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java程序员/">java程序员</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java经典/">java经典</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java网络/">java网络</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/juc/">juc</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/jvm虚拟机/">jvm虚拟机</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/jvm虚拟机/springboot/">springboot</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mac开发工具/">mac开发工具</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/springboot/">springboot</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/博客/">博客</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/命令/">命令</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/婚姻/">婚姻</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发工具/">开发工具</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发效率工具/">开发效率工具</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/微服务/">微服务</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/思考/">思考</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/教育/">教育</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/life/">生活</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/考试/">考试</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/股市/">股市</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/股票/">股票</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机组成/">计算机组成</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/认知/">认知</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/认知/读书/">读书</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书/">读书</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/运维/">运维</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/面试/">面试</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/高质量文章/">高质量文章</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/">$</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/符号/">$符号</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/2的次方/">2的次方</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AI提示词/">AI提示词</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AQS/">AQS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cache/">Cache</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RAM内存/">RAM内存</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ReentrantLock/">ReentrantLock</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ThreadPoolExecutor/">ThreadPoolExecutor</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Value/">\@Value</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/alfred/">alfred</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/apollo-client/">apollo-client</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/centos7/">centos7</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/centos8/">centos8</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/classloader/">classloader</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cursor/">cursor</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/deepseek/">deepseek</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/futex/">futex</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git-revert/">git revert</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/">github</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/https/">https</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iTerm2/">iTerm2</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/interactive-timeout/">interactive_timeout</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/interview/">interview</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/io读写/">io读写</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java-命令/">java 命令</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javaagent/">javaagent</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java多线程/">java多线程</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java并发/">java并发</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java微服务调用/">java微服务调用</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java技术栈/">java技术栈</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java探针/">java探针</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java类加载/">java类加载</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java线程池/">java线程池</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java网络/">java网络</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/juc/">juc</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jvm/">jvm</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jvm虚拟机/">jvm虚拟机</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux网络命令/">linux网络命令</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lsof/">lsof</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mac/">mac</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mac网络命令/">mac网络命令</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql网络/">mysql网络</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/netstat/">netstat</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/prompt/">prompt</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ranger/">ranger</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a><span class="tag-list-count">14</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-aop/">spring aop</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-boot/">spring boot</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-cloud微服务调用/">spring cloud微服务调用</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring-transaction/">spring transaction</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springboot/">springboot</a><span class="tag-list-count">13</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springboot-jar包可运行/">springboot jar包可运行</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springboot-loader/">springboot loader</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springboot加载/">springboot加载</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/springcloud/">springcloud</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tcpip/">tcpip</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tmux/">tmux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/wait-timeout/">wait_timeout</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/书籍会说话/">书籍会说话</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/加密/">加密</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/命令行下载视频/">命令行下载视频</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/大牛技术/">大牛技术</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/婚姻/">婚姻</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开发效率工具/">开发效率工具</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/得失感悟/">得失感悟</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/思考/">思考</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/找工作/">找工作</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技术文章/">技术文章</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/投资/">投资</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/拦截器/">拦截器</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/教育/">教育</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数字签名/">数字签名</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数字证书/">数字证书</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/生活/">生活</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/生活感悟/">生活感悟</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/神器/">神器</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/策略模式/">策略模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/类加载/">类加载</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/考试/">考试</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/股市/">股市</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/读书/">读书</a><span class="tag-list-count">13</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/读取文件/">读取文件</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/读取日志文件/">读取日志文件</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随机写/">随机写</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面试/">面试</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/顺序写/">顺序写</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/" style="font-size: 13px;">$</a> <a href="/tags/符号/" style="font-size: 13px;">$符号</a> <a href="/tags/2的次方/" style="font-size: 13px;">2的次方</a> <a href="/tags/AI提示词/" style="font-size: 13px;">AI提示词</a> <a href="/tags/AQS/" style="font-size: 13px;">AQS</a> <a href="/tags/Cache/" style="font-size: 13px;">Cache</a> <a href="/tags/RAM内存/" style="font-size: 13px;">RAM内存</a> <a href="/tags/ReentrantLock/" style="font-size: 13px;">ReentrantLock</a> <a href="/tags/ThreadPoolExecutor/" style="font-size: 13px;">ThreadPoolExecutor</a> <a href="/tags/Value/" style="font-size: 13px;">\@Value</a> <a href="/tags/alfred/" style="font-size: 13px;">alfred</a> <a href="/tags/apollo-client/" style="font-size: 13px;">apollo-client</a> <a href="/tags/centos7/" style="font-size: 13px;">centos7</a> <a href="/tags/centos8/" style="font-size: 13.25px;">centos8</a> <a href="/tags/classloader/" style="font-size: 13px;">classloader</a> <a href="/tags/cursor/" style="font-size: 13.13px;">cursor</a> <a href="/tags/deepseek/" style="font-size: 13px;">deepseek</a> <a href="/tags/docker/" style="font-size: 13.5px;">docker</a> <a href="/tags/futex/" style="font-size: 13px;">futex</a> <a href="/tags/git/" style="font-size: 13px;">git</a> <a href="/tags/git-revert/" style="font-size: 13px;">git revert</a> <a href="/tags/github/" style="font-size: 13.25px;">github</a> <a href="/tags/hexo/" style="font-size: 13px;">hexo</a> <a href="/tags/http/" style="font-size: 13.13px;">http</a> <a href="/tags/https/" style="font-size: 13.13px;">https</a> <a href="/tags/iTerm2/" style="font-size: 13px;">iTerm2</a> <a href="/tags/interactive-timeout/" style="font-size: 13px;">interactive_timeout</a> <a href="/tags/interview/" style="font-size: 13px;">interview</a> <a href="/tags/io读写/" style="font-size: 13px;">io读写</a> <a href="/tags/java/" style="font-size: 13.75px;">java</a> <a href="/tags/java-命令/" style="font-size: 13px;">java 命令</a> <a href="/tags/javaagent/" style="font-size: 13.25px;">javaagent</a> <a href="/tags/java多线程/" style="font-size: 13.13px;">java多线程</a> <a href="/tags/java并发/" style="font-size: 13px;">java并发</a> <a href="/tags/java微服务调用/" style="font-size: 13px;">java微服务调用</a> <a href="/tags/java技术栈/" style="font-size: 13px;">java技术栈</a> <a href="/tags/java探针/" style="font-size: 13px;">java探针</a> <a href="/tags/java类加载/" style="font-size: 13px;">java类加载</a> <a href="/tags/java线程池/" style="font-size: 13px;">java线程池</a> <a href="/tags/java网络/" style="font-size: 13.13px;">java网络</a> <a href="/tags/juc/" style="font-size: 13px;">juc</a> <a href="/tags/jvm/" style="font-size: 13px;">jvm</a> <a href="/tags/jvm虚拟机/" style="font-size: 13px;">jvm虚拟机</a> <a href="/tags/linux/" style="font-size: 13.5px;">linux</a> <a href="/tags/linux网络命令/" style="font-size: 13.25px;">linux网络命令</a> <a href="/tags/lsof/" style="font-size: 13px;">lsof</a> <a href="/tags/mac/" style="font-size: 13.38px;">mac</a> <a href="/tags/mac网络命令/" style="font-size: 13.13px;">mac网络命令</a> <a href="/tags/mysql/" style="font-size: 13.38px;">mysql</a> <a href="/tags/mysql网络/" style="font-size: 13px;">mysql网络</a> <a href="/tags/netstat/" style="font-size: 13px;">netstat</a> <a href="/tags/prompt/" style="font-size: 13.25px;">prompt</a> <a href="/tags/ranger/" style="font-size: 13px;">ranger</a> <a href="/tags/spring/" style="font-size: 14px;">spring</a> <a href="/tags/spring-aop/" style="font-size: 13.25px;">spring aop</a> <a href="/tags/spring-boot/" style="font-size: 13.63px;">spring boot</a> <a href="/tags/spring-cloud微服务调用/" style="font-size: 13px;">spring cloud微服务调用</a> <a href="/tags/spring-transaction/" style="font-size: 13.13px;">spring transaction</a> <a href="/tags/springboot/" style="font-size: 13.88px;">springboot</a> <a href="/tags/springboot-jar包可运行/" style="font-size: 13px;">springboot jar包可运行</a> <a href="/tags/springboot-loader/" style="font-size: 13px;">springboot loader</a> <a href="/tags/springboot加载/" style="font-size: 13px;">springboot加载</a> <a href="/tags/springcloud/" style="font-size: 13.25px;">springcloud</a> <a href="/tags/tcpip/" style="font-size: 13.13px;">tcpip</a> <a href="/tags/tmux/" style="font-size: 13px;">tmux</a> <a href="/tags/wait-timeout/" style="font-size: 13px;">wait_timeout</a> <a href="/tags/书籍会说话/" style="font-size: 13px;">书籍会说话</a> <a href="/tags/加密/" style="font-size: 13.13px;">加密</a> <a href="/tags/命令行下载视频/" style="font-size: 13px;">命令行下载视频</a> <a href="/tags/大牛技术/" style="font-size: 13px;">大牛技术</a> <a href="/tags/婚姻/" style="font-size: 13px;">婚姻</a> <a href="/tags/开发效率工具/" style="font-size: 13.13px;">开发效率工具</a> <a href="/tags/得失感悟/" style="font-size: 13px;">得失感悟</a> <a href="/tags/思考/" style="font-size: 13px;">思考</a> <a href="/tags/找工作/" style="font-size: 13px;">找工作</a> <a href="/tags/技术文章/" style="font-size: 13px;">技术文章</a> <a href="/tags/投资/" style="font-size: 13.25px;">投资</a> <a href="/tags/拦截器/" style="font-size: 13px;">拦截器</a> <a href="/tags/教育/" style="font-size: 13px;">教育</a> <a href="/tags/数字签名/" style="font-size: 13.13px;">数字签名</a> <a href="/tags/数字证书/" style="font-size: 13.13px;">数字证书</a> <a href="/tags/生活/" style="font-size: 13.13px;">生活</a> <a href="/tags/生活感悟/" style="font-size: 13px;">生活感悟</a> <a href="/tags/神器/" style="font-size: 13px;">神器</a> <a href="/tags/策略模式/" style="font-size: 13px;">策略模式</a> <a href="/tags/类加载/" style="font-size: 13.13px;">类加载</a> <a href="/tags/考试/" style="font-size: 13.25px;">考试</a> <a href="/tags/股市/" style="font-size: 13.13px;">股市</a> <a href="/tags/读书/" style="font-size: 13.88px;">读书</a> <a href="/tags/读取文件/" style="font-size: 13px;">读取文件</a> <a href="/tags/读取日志文件/" style="font-size: 13px;">读取日志文件</a> <a href="/tags/随机写/" style="font-size: 13px;">随机写</a> <a href="/tags/面试/" style="font-size: 13px;">面试</a> <a href="/tags/顺序写/" style="font-size: 13px;">顺序写</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/11/">十一月 2025</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/10/">十月 2025</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/08/">八月 2025</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/07/">七月 2025</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">六月 2025</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/05/">五月 2025</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">三月 2025</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/01/">一月 2025</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">十一月 2024</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">八月 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/07/">七月 2024</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">六月 2024</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">五月 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">四月 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/01/">一月 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">十一月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">三月 2023</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">十二月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">六月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">五月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">十一月 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/life/">生活</a>
              </p>
              <p class="item-title">
                <a href="/2025/11/15/生活-活生生的活着/" class="title">男性强身健体的运动</a>
              </p>
              <p class="item-date">
                <time datetime="2025-11-15T03:10:10.000Z" itemprop="datePublished">2025-11-15</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2025/10/11/穷人的特征/" class="title">穷人的特征</a>
              </p>
              <p class="item-date">
                <time datetime="2025-10-11T02:05:32.000Z" itemprop="datePublished">2025-10-11</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2025/10/11/如何培养一个优秀的小孩/" class="title">如何培养一个优秀的小孩</a>
              </p>
              <p class="item-date">
                <time datetime="2025-10-11T01:05:32.000Z" itemprop="datePublished">2025-10-11</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/考试/">考试</a>
              </p>
              <p class="item-title">
                <a href="/2025/10/09/考公记录-行测-1-言语理解/" class="title">言语理解</a>
              </p>
              <p class="item-date">
                <time datetime="2025-10-09T03:10:59.000Z" itemprop="datePublished">2025-10-09</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/考试/">考试</a>
              </p>
              <p class="item-title">
                <a href="/2025/10/09/考公记录-行测/" class="title">考试记录</a>
              </p>
              <p class="item-date">
                <time datetime="2025-10-09T03:10:59.000Z" itemprop="datePublished">2025-10-09</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
  <aside class="sidebar sidebar-toc collapse   in  " id="collapseToc" itemscope="" itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#java"><span class="toc-number">1.</span> <span class="toc-text">java</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#jvm"><span class="toc-number">1.1.</span> <span class="toc-text">jvm</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jvm内存区域"><span class="toc-number">1.1.1.</span> <span class="toc-text">jvm内存区域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jvm多线程并发创建对象解决方案"><span class="toc-number">1.1.2.</span> <span class="toc-text">jvm多线程并发创建对象解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存回收-gc-方法论"><span class="toc-number">1.1.3.</span> <span class="toc-text">内存回收(gc) - 方法论</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#内存回收-gc-如何发起"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">内存回收(gc)如何发起</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内存回收-gc-如何加速"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">内存回收(gc)如何加速</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内存回收如何正确"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">内存回收如何正确</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存回收-gc-实践者"><span class="toc-number">1.1.4.</span> <span class="toc-text">内存回收(gc) - 实践者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾收集器日志"><span class="toc-number">1.1.5.</span> <span class="toc-text">垃圾收集器日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#故障处理工具"><span class="toc-number">1.1.6.</span> <span class="toc-text">故障处理工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#内置"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">内置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#外置"><span class="toc-number">1.1.6.2.</span> <span class="toc-text">外置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存回收-gc-发生的场景和java命令查看oom的方法"><span class="toc-number">1.1.7.</span> <span class="toc-text">内存回收(gc) 发生的场景和java命令查看oom的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#jvm-oom-后服务还能运行吗"><span class="toc-number">1.1.7.1.</span> <span class="toc-text">jvm oom 后服务还能运行吗</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#class-loader-类加载"><span class="toc-number">1.1.8.</span> <span class="toc-text">class loader(类加载)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#类加载过程"><span class="toc-number">1.1.8.1.</span> <span class="toc-text">类加载过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#双亲委派机制"><span class="toc-number">1.1.8.2.</span> <span class="toc-text">双亲委派机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#哪些组件破坏了双亲委派机制"><span class="toc-number">1.1.8.3.</span> <span class="toc-text">哪些组件破坏了双亲委派机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象内存布局-and-CAS"><span class="toc-number">1.1.9.</span> <span class="toc-text">对象内存布局 and CAS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#compressed-class-pointer"><span class="toc-number">1.1.10.</span> <span class="toc-text">compressed class pointer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java8-新特性教程"><span class="toc-number">1.1.11.</span> <span class="toc-text">Java8 新特性教程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HotSpot"><span class="toc-number">1.1.11.1.</span> <span class="toc-text">HotSpot</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-编程语言"><span class="toc-number">1.1.11.2.</span> <span class="toc-text">Java 编程语言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Date-API-日期相关API"><span class="toc-number">1.1.11.3.</span> <span class="toc-text">Date API(日期相关API)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#集合"><span class="toc-number">1.1.11.4.</span> <span class="toc-text">集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Concurrency"><span class="toc-number">1.1.11.5.</span> <span class="toc-text">Concurrency</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Tools"><span class="toc-number">1.1.11.6.</span> <span class="toc-text">Tools</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile-可见性和禁止指令重排"><span class="toc-number">1.1.12.</span> <span class="toc-text">volatile 可见性和禁止指令重排</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile在jvm中的实现代码-bytecodeinterpreter-cpp"><span class="toc-number">1.1.13.</span> <span class="toc-text">volatile在jvm中的实现代码 bytecodeinterpreter.cpp</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java锁"><span class="toc-number">1.2.</span> <span class="toc-text">java锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sychronized"><span class="toc-number">1.2.1.</span> <span class="toc-text">sychronized</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sychronized原理，字节码层级的支持entermonitor-exitmonitor-编译层级的支持lock-cmpxchg指令"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">sychronized原理，字节码层级的支持entermonitor exitmonitor; 编译层级的支持lock cmpxchg指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sychronized锁升级过程"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">sychronized锁升级过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sychronized有锁升级，那么有锁降级吗？"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">sychronized有锁升级，那么有锁降级吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock"><span class="toc-number">1.2.2.</span> <span class="toc-text">Lock</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ReentantLock"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">ReentantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Reentantlock的实现原理"><span class="toc-number">1.2.2.1.1.</span> <span class="toc-text">Reentantlock的实现原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Condition实现原理"><span class="toc-number">1.2.2.1.2.</span> <span class="toc-text">Condition实现原理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ReentantReadWriteLock"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">ReentantReadWriteLock</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized和Lock对比"><span class="toc-number">1.2.3.</span> <span class="toc-text">synchronized和Lock对比</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Lock相较于Synchronized优势"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">Lock相较于Synchronized优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lock-vs-Synchronized分别适用什么样的场景"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">Lock vs Synchronized分别适用什么样的场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lock-vs-Synchronized知识整体参考："><span class="toc-number">1.2.3.3.</span> <span class="toc-text">Lock vs Synchronized知识整体参考：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS"><span class="toc-number">1.2.4.</span> <span class="toc-text">AQS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AQS-内部的关键是什么"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">AQS 内部的关键是什么</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BlockingQueue"><span class="toc-number">1.2.5.</span> <span class="toc-text">BlockingQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedBlockingQueue"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">LinkedBlockingQueue</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap"><span class="toc-number">1.2.6.</span> <span class="toc-text">HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#属性值的含义"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">属性值的含义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap多线程下不安全的原因"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">HashMap多线程下不安全的原因</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-number">1.2.7.</span> <span class="toc-text">ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ConcurrentHashMap是如何做到线程安全的，他的数据结构是什么"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">ConcurrentHashMap是如何做到线程安全的，他的数据结构是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConcurrentHashMap真的安全吗？"><span class="toc-number">1.2.7.2.</span> <span class="toc-text">ConcurrentHashMap真的安全吗？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#threadLocal"><span class="toc-number">1.3.</span> <span class="toc-text">threadLocal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-threadLocalMap-的key为啥是threadLocal对象呢，用threadId可以吗"><span class="toc-number">1.3.1.</span> <span class="toc-text">C. threadLocalMap 的key为啥是threadLocal对象呢，用threadId可以吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#E-为什么ThreadLocalMap-采用-线性探测法-开放地址法来解决哈希冲突，为啥不用-Hashmap-的链表法"><span class="toc-number">1.3.2.</span> <span class="toc-text">E. 为什么ThreadLocalMap 采用(线性探测法)开放地址法来解决哈希冲突，为啥不用 Hashmap 的链表法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D-threadLocal-的魔数0x61c88647"><span class="toc-number">1.3.3.</span> <span class="toc-text">D. threadLocal 的魔数0x61c88647</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-threadLocalMap-的Entry对象为啥是弱引用的呢"><span class="toc-number">1.3.4.</span> <span class="toc-text">B. threadLocalMap 的Entry对象为啥是弱引用的呢</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#F-threadLocal-会发生内存泄漏吗"><span class="toc-number">1.3.5.</span> <span class="toc-text">F. threadLocal 会发生内存泄漏吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#H-代码实践查看gc-后Entry的key-和value是否被回收"><span class="toc-number">1.3.6.</span> <span class="toc-text">H. 代码实践查看gc 后Entry的key 和value是否被回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#M-threadLocal-过期key的清理机制是什么？探测-触发-式清理：replaceStaleEntry；启发式清理：cleanSomeSlots"><span class="toc-number">1.3.7.</span> <span class="toc-text">M. threadLocal 过期key的清理机制是什么？探测(触发)式清理：replaceStaleEntry；启发式清理：cleanSomeSlots</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G-ThreadLocalMap和-HashMap的区别。ThreadLocalMap-和HashMap的功能类似，但是实现上却有很大的不同："><span class="toc-number">1.3.8.</span> <span class="toc-text">G. ThreadLocalMap和 HashMap的区别。ThreadLocalMap 和HashMap的功能类似，但是实现上却有很大的不同：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程安全的队列"><span class="toc-number">1.4.</span> <span class="toc-text">线程安全的队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ConcurrentLinkedQueue"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">ConcurrentLinkedQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedBlockingQueue-1"><span class="toc-number">1.4.0.2.</span> <span class="toc-text">LinkedBlockingQueue</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#threadpoolExecutor-线程池"><span class="toc-number">1.5.</span> <span class="toc-text">threadpoolExecutor 线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池的执行流程"><span class="toc-number">1.5.1.</span> <span class="toc-text">线程池的执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池核心线程何时销毁"><span class="toc-number">1.5.2.</span> <span class="toc-text">线程池核心线程何时销毁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#几个核心问题"><span class="toc-number">1.5.3.</span> <span class="toc-text">几个核心问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池使用注意事项"><span class="toc-number">1.5.4.</span> <span class="toc-text">线程池使用注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#线程池设置多少合适呢"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">线程池设置多少合适呢</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关于线程池胡思乱想产生的问题"><span class="toc-number">1.5.5.</span> <span class="toc-text">关于线程池胡思乱想产生的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池运用不当导致的问题的实例"><span class="toc-number">1.5.6.</span> <span class="toc-text">线程池运用不当导致的问题的实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis-Redis-远程字典服务器-Remote-Dictionary-Server"><span class="toc-number">1.6.</span> <span class="toc-text">redis - Redis 远程字典服务器 (Remote Dictionary Server)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#why-is-redis-so-fast"><span class="toc-number">1.6.1.</span> <span class="toc-text">why is redis so fast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-线程模型"><span class="toc-number">1.6.2.</span> <span class="toc-text">redis 线程模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis缓存穿透，缓存击穿，缓存雪崩-布隆过滤器"><span class="toc-number">1.6.3.</span> <span class="toc-text">redis缓存穿透，缓存击穿，缓存雪崩 布隆过滤器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-分布式锁"><span class="toc-number">1.6.4.</span> <span class="toc-text">redis 分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-上锁的问题"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">1. 上锁的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-解锁的问题"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">2. 解锁的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-超时时间的问题-锁的超时时间怎么计算合适呢？"><span class="toc-number">1.6.4.3.</span> <span class="toc-text">3. 超时时间的问题 - 锁的超时时间怎么计算合适呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-加解锁代码位置问题"><span class="toc-number">1.6.4.4.</span> <span class="toc-text">4. 加解锁代码位置问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-主从架构带来锁的问题"><span class="toc-number">1.6.4.5.</span> <span class="toc-text">5. 主从架构带来锁的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-key的过期策略"><span class="toc-number">1.6.5.</span> <span class="toc-text">redis key的过期策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-内存淘汰策略-Key-eviction-it-s-policies-is-LRU-LFU-etc"><span class="toc-number">1.6.6.</span> <span class="toc-text">redis 内存淘汰策略 Key eviction (it`s policies is LRU, LFU, etc.)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LRU算法-突出访问的先后-顺序"><span class="toc-number">1.6.6.1.</span> <span class="toc-text">LRU算法 - 突出访问的先后(顺序)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LFU算法-突出访问的次数-频率"><span class="toc-number">1.6.6.2.</span> <span class="toc-text">LFU算法 - 突出访问的次数(频率)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-bigKey问题"><span class="toc-number">1.6.7.</span> <span class="toc-text">redis bigKey问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-hotKey问题"><span class="toc-number">1.6.8.</span> <span class="toc-text">redis hotKey问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-zset底层实现原理"><span class="toc-number">1.6.9.</span> <span class="toc-text">redis zset底层实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis实现高可用-怎么防止数据丢失"><span class="toc-number">1.6.10.</span> <span class="toc-text">Redis实现高可用(怎么防止数据丢失)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis在高并发-高性能的应用"><span class="toc-number">1.6.11.</span> <span class="toc-text">redis在高并发 高性能的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#高频面试题"><span class="toc-number">1.6.12.</span> <span class="toc-text">高频面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redis如何实现延时队列"><span class="toc-number">1.6.12.1.</span> <span class="toc-text">redis如何实现延时队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis集群下一组一个master和两个slave挂了，-redis还能提供服务吗"><span class="toc-number">1.6.12.2.</span> <span class="toc-text">redis集群下一组一个master和两个slave挂了， redis还能提供服务吗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis-cluster的原理"><span class="toc-number">1.6.12.3.</span> <span class="toc-text">redis cluster的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis-hotkey如何解决，超高的qps-写操作"><span class="toc-number">1.6.12.4.</span> <span class="toc-text">redis hotkey如何解决，超高的qps 写操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis-高并发写操作"><span class="toc-number">1.6.12.5.</span> <span class="toc-text">redis 高并发写操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#问题描述"><span class="toc-number">1.6.12.5.1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#解决方案"><span class="toc-number">1.6.12.5.2.</span> <span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis-zset-底层的数据结构是什么"><span class="toc-number">1.6.12.6.</span> <span class="toc-text">redis zset 底层的数据结构是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#算法实现"><span class="toc-number">1.6.12.7.</span> <span class="toc-text">算法实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#高并发下redis和数据库的强一致如何保证-redis与mysql数据一致性"><span class="toc-number">1.6.12.8.</span> <span class="toc-text">高并发下redis和数据库的强一致如何保证(redis与mysql数据一致性)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mysql"><span class="toc-number">1.7.</span> <span class="toc-text">mysql</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Innodb"><span class="toc-number">1.7.1.</span> <span class="toc-text">Innodb</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#索引数据结构-B-tree"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">索引数据结构 B+tree</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mysql-索引的底层实现原理"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">Mysql 索引的底层实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer-Pool"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">Buffer Pool</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Buffer-Pool中的LRU淘汰算法"><span class="toc-number">1.7.1.3.1.</span> <span class="toc-text">Buffer Pool中的LRU淘汰算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#change-buffer详解"><span class="toc-number">1.7.1.4.</span> <span class="toc-text">change buffer详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mysql-写多读少场景，更新一条语句时，条件中唯一索引和普通索引哪个选择更好的，为什么"><span class="toc-number">1.7.1.5.</span> <span class="toc-text">mysql 写多读少场景，更新一条语句时，条件中唯一索引和普通索引哪个选择更好的，为什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Change-buffer-与-Buffer-Pool-的区别"><span class="toc-number">1.7.1.6.</span> <span class="toc-text">Change buffer 与 Buffer Pool 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#事务"><span class="toc-number">1.7.1.7.</span> <span class="toc-text">事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#幻读的解决"><span class="toc-number">1.7.1.8.</span> <span class="toc-text">幻读的解决</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sql语句加锁分析"><span class="toc-number">1.7.1.9.</span> <span class="toc-text">sql语句加锁分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-普通select（也叫一致性读）语句加锁分析"><span class="toc-number">1.7.1.9.1.</span> <span class="toc-text">1.普通select（也叫一致性读）语句加锁分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-特殊select（也叫锁定读-in-shard-mode-and-for-update-）语句加锁分析"><span class="toc-number">1.7.1.9.2.</span> <span class="toc-text">2.特殊select（也叫锁定读(in shard mode and for update)）语句加锁分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-update-and-delete语句时加锁分析"><span class="toc-number">1.7.1.9.3.</span> <span class="toc-text">3.update and delete语句时加锁分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mysql事务是如何实现的，回滚时是怎么个操作流程，"><span class="toc-number">1.7.1.10.</span> <span class="toc-text">mysql事务是如何实现的，回滚时是怎么个操作流程，</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mysql为什么使用B-树，而mongdb使用B树呢"><span class="toc-number">1.7.1.11.</span> <span class="toc-text">mysql为什么使用B+树，而mongdb使用B树呢</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mysql主从的实现方式，哪些方式"><span class="toc-number">1.7.1.12.</span> <span class="toc-text">mysql主从的实现方式，哪些方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mysql是怎样运行的小结"><span class="toc-number">1.7.1.13.</span> <span class="toc-text">mysql是怎样运行的小结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redo-log-amp-binlog-amp-undo-log写入数据的顺序和具体流程-自问"><span class="toc-number">1.7.1.14.</span> <span class="toc-text">redo log &amp; binlog &amp; undo log写入数据的顺序和具体流程  自问</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#bufferPool-redo日志-undo日志-分别何时产生，何时刷盘，何时删除"><span class="toc-number">1.7.1.14.1.</span> <span class="toc-text">bufferPool redo日志 undo日志 分别何时产生，何时刷盘，何时删除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#两个重要的指针-roll-pointor-amp-next-record"><span class="toc-number">1.7.1.14.2.</span> <span class="toc-text">两个重要的指针 roll-pointor &amp; next-record</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mysql主从复制延迟解决方案"><span class="toc-number">1.7.1.15.</span> <span class="toc-text">mysql主从复制延迟解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#主从复制原理"><span class="toc-number">1.7.1.15.1.</span> <span class="toc-text">主从复制原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#延迟原因"><span class="toc-number">1.7.1.15.2.</span> <span class="toc-text">延迟原因</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#解决方案-1"><span class="toc-number">1.7.1.15.3.</span> <span class="toc-text">解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#分治-分库分表"><span class="toc-number">1.7.1.15.3.1.</span> <span class="toc-text">分治 - 分库分表</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#从库同步完成后响应"><span class="toc-number">1.7.1.15.3.2.</span> <span class="toc-text">从库同步完成后响应</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#适当引入缓存"><span class="toc-number">1.7.1.15.3.3.</span> <span class="toc-text">适当引入缓存</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#多线程重放RelayLog"><span class="toc-number">1.7.1.15.3.4.</span> <span class="toc-text">多线程重放RelayLog</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#少量读业务直连主库"><span class="toc-number">1.7.1.15.3.5.</span> <span class="toc-text">少量读业务直连主库</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kafka"><span class="toc-number">1.8.</span> <span class="toc-text">kafka</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#可靠性的保证-kafka如何保证消息的可靠的"><span class="toc-number">1.8.1.</span> <span class="toc-text">可靠性的保证(kafka如何保证消息的可靠的)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#生产者的可靠性保证"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">生产者的可靠性保证</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#acks策略"><span class="toc-number">1.8.1.1.1.</span> <span class="toc-text">acks策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ISR"><span class="toc-number">1.8.1.1.2.</span> <span class="toc-text">ISR</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#min-insync-replicas"><span class="toc-number">1.8.1.1.3.</span> <span class="toc-text">min.insync.replicas</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#unclean-leader-election-enable"><span class="toc-number">1.8.1.1.4.</span> <span class="toc-text">unclean.leader.election.enable</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#重试"><span class="toc-number">1.8.1.1.5.</span> <span class="toc-text">重试</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CP-or-AP"><span class="toc-number">1.8.1.1.6.</span> <span class="toc-text">CP or AP</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#broker的可靠性保证"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">broker的可靠性保证</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#副本机制"><span class="toc-number">1.8.1.2.1.</span> <span class="toc-text">副本机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#同步机制"><span class="toc-number">1.8.1.2.2.</span> <span class="toc-text">同步机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#offset详解"><span class="toc-number">1.8.2.</span> <span class="toc-text">offset详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#生产者发送消息到broker的过程"><span class="toc-number">1.8.3.</span> <span class="toc-text">生产者发送消息到broker的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#消费者从broker消费消息的过程"><span class="toc-number">1.8.4.</span> <span class="toc-text">消费者从broker消费消息的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kafka-offset存在哪里，为啥用kafka不是其他消息组件，他最大能支持多少并发，如何保证消息的可靠的"><span class="toc-number">1.8.5.</span> <span class="toc-text">kafka offset存在哪里，为啥用kafka不是其他消息组件，他最大能支持多少并发，如何保证消息的可靠的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kafka-是如何保证消息可靠的"><span class="toc-number">1.8.6.</span> <span class="toc-text">kafka 是如何保证消息可靠的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1）Producer-端发送消息给-Kafka-Broker-端。"><span class="toc-number">1.8.6.1.</span> <span class="toc-text">1）Producer 端发送消息给 Kafka Broker 端。</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#丢消息场景："><span class="toc-number">1.8.6.1.1.</span> <span class="toc-text">丢消息场景：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#解决方案-2"><span class="toc-number">1.8.6.1.2.</span> <span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2）Kafka-Broker-将消息进行同步并持久化数据。"><span class="toc-number">1.8.6.2.</span> <span class="toc-text">2）Kafka Broker 将消息进行同步并持久化数据。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3）Consumer-端从Kafka-Broker-将消息拉取并进行消费。"><span class="toc-number">1.8.6.3.</span> <span class="toc-text">3）Consumer 端从Kafka Broker 将消息拉取并进行消费。</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#消费者如何保证一定成功消费消息-重试实现"><span class="toc-number">1.8.6.3.1.</span> <span class="toc-text">消费者如何保证一定成功消费消息 - 重试实现</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#kafka-消费重试实现"><span class="toc-number">1.8.6.3.1.1.</span> <span class="toc-text">kafka 消费重试实现</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#代码里重试"><span class="toc-number">1.8.6.3.1.2.</span> <span class="toc-text">代码里重试</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#offset重置"><span class="toc-number">1.8.6.3.1.3.</span> <span class="toc-text">offset重置</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#基于数据库任务表的扫描"><span class="toc-number">1.8.6.3.1.4.</span> <span class="toc-text">基于数据库任务表的扫描</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#新增重试队列-创建一个重试topic"><span class="toc-number">1.8.6.3.1.5.</span> <span class="toc-text">新增重试队列 - 创建一个重试topic</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kafka-rebalance"><span class="toc-number">1.8.7.</span> <span class="toc-text">kafka rebalance</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#原因"><span class="toc-number">1.8.7.1.</span> <span class="toc-text">原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rebalance时间长原因"><span class="toc-number">1.8.7.2.</span> <span class="toc-text">rebalance时间长原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有关参数"><span class="toc-number">1.8.7.3.</span> <span class="toc-text">有关参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方案"><span class="toc-number">1.8.7.4.</span> <span class="toc-text">方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kafka-有序性"><span class="toc-number">1.8.8.</span> <span class="toc-text">kafka 有序性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#producer发送消息的有序性"><span class="toc-number">1.8.8.1.</span> <span class="toc-text">producer发送消息的有序性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#consumer多线程消费消息，如何保证消息消费有序性"><span class="toc-number">1.8.8.2.</span> <span class="toc-text">consumer多线程消费消息，如何保证消息消费有序性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring"><span class="toc-number">1.9.</span> <span class="toc-text">spring</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#spring-boot"><span class="toc-number">1.9.1.</span> <span class="toc-text">spring boot</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spring-cloud"><span class="toc-number">1.9.2.</span> <span class="toc-text">spring cloud</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接口幂等性"><span class="toc-number">1.10.</span> <span class="toc-text">接口幂等性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#计算机网络"><span class="toc-number">1.11.</span> <span class="toc-text">计算机网络</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io"><span class="toc-number">1.12.</span> <span class="toc-text">io</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#同步异步"><span class="toc-number">1.12.1.</span> <span class="toc-text">同步异步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IO模型"><span class="toc-number">1.12.1.1.</span> <span class="toc-text">IO模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO的两个阶段"><span class="toc-number">1.12.1.2.</span> <span class="toc-text">IO的两个阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#同步，异步的区别"><span class="toc-number">1.12.1.3.</span> <span class="toc-text">同步，异步的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#阻塞和非阻塞"><span class="toc-number">1.12.1.4.</span> <span class="toc-text">阻塞和非阻塞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#结论"><span class="toc-number">1.12.1.5.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp-ip-网络"><span class="toc-number">1.12.2.</span> <span class="toc-text">tcp/ip 网络</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据结构"><span class="toc-number">1.13.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树"><span class="toc-number">1.13.1.</span> <span class="toc-text">二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法"><span class="toc-number">1.13.2.</span> <span class="toc-text">算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#架构"><span class="toc-number">1.14.</span> <span class="toc-text">架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#架构理论"><span class="toc-number">1.14.1.</span> <span class="toc-text">架构理论</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#软件开发中的原则-SOLID"><span class="toc-number">1.14.1.1.</span> <span class="toc-text">软件开发中的原则 - SOLID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分布式理论-CAP"><span class="toc-number">1.14.1.2.</span> <span class="toc-text">分布式理论 - CAP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分布式理论-BASE"><span class="toc-number">1.14.1.3.</span> <span class="toc-text">分布式理论 - BASE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#事务理论-ACID"><span class="toc-number">1.14.1.4.</span> <span class="toc-text">事务理论 - ACID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#微服务基础-康威定律"><span class="toc-number">1.14.1.5.</span> <span class="toc-text">微服务基础 - 康威定律</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#性能"><span class="toc-number">1.14.2.</span> <span class="toc-text">性能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#性能优化"><span class="toc-number">1.14.2.1.</span> <span class="toc-text">性能优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#性能优化指标"><span class="toc-number">1.14.2.2.</span> <span class="toc-text">性能优化指标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#性能优化-三个“要”原则是："><span class="toc-number">1.14.2.3.</span> <span class="toc-text">性能优化 三个“要”原则是：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#性能优化-三个“不要”的原则是："><span class="toc-number">1.14.2.4.</span> <span class="toc-text">性能优化 三个“不要”的原则是：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可扩展性"><span class="toc-number">1.14.3.</span> <span class="toc-text">可扩展性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-预测变化"><span class="toc-number">1.14.3.1.</span> <span class="toc-text">1. 预测变化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-应对变化"><span class="toc-number">1.14.3.2.</span> <span class="toc-text">2. 应对变化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可扩展性-vs-可伸缩性区别"><span class="toc-number">1.14.3.3.</span> <span class="toc-text">可扩展性 vs 可伸缩性区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可用性"><span class="toc-number">1.14.4.</span> <span class="toc-text">可用性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#可用性度量"><span class="toc-number">1.14.4.1.</span> <span class="toc-text">可用性度量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#高可用"><span class="toc-number">1.14.4.2.</span> <span class="toc-text">高可用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可靠性"><span class="toc-number">1.14.5.</span> <span class="toc-text">可靠性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可用性-vs-可靠性区别"><span class="toc-number">1.14.6.</span> <span class="toc-text">可用性 vs 可靠性区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#你们那微服务是怎么划-拆-分的"><span class="toc-number">1.14.7.</span> <span class="toc-text">你们那微服务是怎么划(拆)分的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么拆分"><span class="toc-number">1.14.7.1.</span> <span class="toc-text">为什么拆分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何拆分-拆分策略"><span class="toc-number">1.14.7.2.</span> <span class="toc-text">如何拆分 - 拆分策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#微服务间数据一致性"><span class="toc-number">1.14.8.</span> <span class="toc-text">微服务间数据一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#理论依据"><span class="toc-number">1.14.8.1.</span> <span class="toc-text">理论依据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#事件通知模式"><span class="toc-number">1.14.8.2.</span> <span class="toc-text">事件通知模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#同步事件通知"><span class="toc-number">1.14.8.2.1.</span> <span class="toc-text">同步事件通知</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#同步事件通知问题"><span class="toc-number">1.14.8.2.2.</span> <span class="toc-text">同步事件通知问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#异步事件"><span class="toc-number">1.14.8.2.3.</span> <span class="toc-text">异步事件</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#本地事件服务"><span class="toc-number">1.14.8.2.3.1.</span> <span class="toc-text">本地事件服务</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#外部事件服务"><span class="toc-number">1.14.8.2.3.2.</span> <span class="toc-text">外部事件服务</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#消费者如何保证一定成功消费消息-重试实现-1"><span class="toc-number">1.14.8.2.3.3.</span> <span class="toc-text">消费者如何保证一定成功消费消息 - 重试实现</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#服务如何做到高可用"><span class="toc-number">1.14.9.</span> <span class="toc-text">服务如何做到高可用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#服务如何做到高并发"><span class="toc-number">1.14.10.</span> <span class="toc-text">服务如何做到高并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#服务如何做到高性能"><span class="toc-number">1.14.11.</span> <span class="toc-text">服务如何做到高性能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#系统设计-架构设计面试题"><span class="toc-number">1.15.</span> <span class="toc-text">系统设计/架构设计面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#系统-架构设计步骤"><span class="toc-number">1.15.1.</span> <span class="toc-text">系统/架构设计步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何设计一个秒杀系统"><span class="toc-number">1.15.2.</span> <span class="toc-text">如何设计一个秒杀系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#特点"><span class="toc-number">1.15.2.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#访问"><span class="toc-number">1.15.2.2.</span> <span class="toc-text">访问</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#秒杀url-动态化"><span class="toc-number">1.15.2.2.1.</span> <span class="toc-text">秒杀url - 动态化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#秒杀商品详情获取"><span class="toc-number">1.15.2.2.2.</span> <span class="toc-text">秒杀商品详情获取</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#下单"><span class="toc-number">1.15.2.3.</span> <span class="toc-text">下单</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#下单请求太多"><span class="toc-number">1.15.2.3.1.</span> <span class="toc-text">下单请求太多</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#商品不少卖-高并发下怎么做余额扣减"><span class="toc-number">1.15.2.3.2.</span> <span class="toc-text">商品不少卖 - 高并发下怎么做余额扣减</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#存储"><span class="toc-number">1.15.2.3.3.</span> <span class="toc-text">存储</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#使用缓存，定时写-DB"><span class="toc-number">1.15.2.3.3.1.</span> <span class="toc-text">使用缓存，定时写 DB</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#使用MQ-可选"><span class="toc-number">1.15.2.3.3.2.</span> <span class="toc-text">使用MQ(可选)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#高可用-1"><span class="toc-number">1.15.2.4.</span> <span class="toc-text">高可用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#性能测试"><span class="toc-number">1.15.2.5.</span> <span class="toc-text">性能测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#短-URL-系统是怎么设计的？"><span class="toc-number">1.15.3.</span> <span class="toc-text">短 URL 系统是怎么设计的？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#如何生成"><span class="toc-number">1.15.3.1.</span> <span class="toc-text">如何生成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何存储"><span class="toc-number">1.15.3.2.</span> <span class="toc-text">如何存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何访问"><span class="toc-number">1.15.3.3.</span> <span class="toc-text">如何访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-number">1.15.3.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何设计一个RPC系统"><span class="toc-number">1.15.4.</span> <span class="toc-text">如何设计一个RPC系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#架构心得"><span class="toc-number">1.16.</span> <span class="toc-text">架构心得</span></a></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-java技术栈重要知识点草集" class="article article-type-post" itemscope="" itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      java技术栈重要知识点草集
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2021/07/17/java技术栈重要知识点草集/" class="article-date">
	  <time datetime="2021-07-17T08:02:31.000Z" itemprop="datePublished">2021-07-17</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/java/">java</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/java技术栈/">java技术栈</a>
  </span>


        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill" aria-hidden="true"></i>
	    <span id="busuanzi_container_page_pv">
			<span id="busuanzi_value_page_pv">0</span>
		</span>
	</span>


        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2021/07/17/java技术栈重要知识点草集/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 32.2k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 118(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="java"><a href="#java" class="headerlink" title="java"></a>java</h1><h2 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h2><h3 id="jvm内存区域"><a href="#jvm内存区域" class="headerlink" title="jvm内存区域"></a>jvm内存区域</h3><p>程序计数器、堆、栈、本地方法栈、方法区</p>
<h3 id="jvm多线程并发创建对象解决方案"><a href="#jvm多线程并发创建对象解决方案" class="headerlink" title="jvm多线程并发创建对象解决方案"></a>jvm多线程并发创建对象解决方案</h3><ol>
<li>cas+失败重试</li>
<li>每个线程留出一块内存：本地线程分配缓存(Thread Local Allocation Buffer - TLAB)</li>
</ol>
<h3 id="内存回收-gc-方法论"><a href="#内存回收-gc-方法论" class="headerlink" title="内存回收(gc) - 方法论"></a>内存回收(gc) - 方法论</h3><p>垃圾收集算法      对应垃圾收集算法        分代</p>
<ol>
<li>标记 - 清除   CMS                  年老代</li>
<li>标记 - 复制   ParNew    Serial     年轻代  </li>
<li>标记 - 整理   G1(整体)   Serial-Old 年老代</li>
</ol>
<h4 id="内存回收-gc-如何发起"><a href="#内存回收-gc-如何发起" class="headerlink" title="内存回收(gc)如何发起"></a>内存回收(gc)如何发起</h4><p>GC Roots</p>
<h4 id="内存回收-gc-如何加速"><a href="#内存回收-gc-如何加速" class="headerlink" title="内存回收(gc)如何加速"></a>内存回收(gc)如何加速</h4><p>记忆集与卡表 - 解决跨代引用<br>写屏障 - 解决卡表数据中引用类型字段何时更新的问题</p>
<h4 id="内存回收如何正确"><a href="#内存回收如何正确" class="headerlink" title="内存回收如何正确"></a>内存回收如何正确</h4><p>增量更新<br>原始快照      </p>
<h3 id="内存回收-gc-实践者"><a href="#内存回收-gc-实践者" class="headerlink" title="内存回收(gc) - 实践者"></a>内存回收(gc) - 实践者</h3><p>垃圾收集器，代表有 CMS，G1</p>
<h3 id="垃圾收集器日志"><a href="#垃圾收集器日志" class="headerlink" title="垃圾收集器日志"></a>垃圾收集器日志</h3><p>P123</p>
<h3 id="故障处理工具"><a href="#故障处理工具" class="headerlink" title="故障处理工具"></a>故障处理工具</h3><h4 id="内置"><a href="#内置" class="headerlink" title="内置"></a>内置</h4><p>命令行：jps jinfo jstack jstat  jmap</p>
<p>jinfo: jvm的配置信息</p>
<p>jstack: 查看线程信息</p>
<p>jstat: 统计gc，class loader信息等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-gc：统计 jdk gc时 heap信息，以使用空间字节数表示</span><br><span class="line">-gcutil：统计 gc时， heap情况，以使用空间的百分比表示</span><br><span class="line">-class：统计 class loader行为信息</span><br><span class="line">-compile：统计编译行为信息</span><br><span class="line">-gccapacity：统计不同 generations（新生代，老年代，持久代）的 heap容量情况</span><br><span class="line">-gccause：统计引起 gc的事件</span><br><span class="line">-gcnew：统计 gc时，新生代的情况</span><br><span class="line">-gcnewcapacity：统计 gc时，新生代 heap容量</span><br><span class="line">-gcold：统计 gc时，老年代的情况</span><br><span class="line">-gcoldcapacity：统计 gc时，老年代 heap容量</span><br><span class="line">-gcpermcapacity：统计 gc时， permanent区 heap容量</span><br></pre></td></tr></table></figure></p>
<p>可视化：jconsole jhsdb</p>
<h4 id="外置"><a href="#外置" class="headerlink" title="外置"></a>外置</h4><p>可视化：jmc visualVM mat(eclipse memory analyzer) HeapAnalyer</p>
<h3 id="内存回收-gc-发生的场景和java命令查看oom的方法"><a href="#内存回收-gc-发生的场景和java命令查看oom的方法" class="headerlink" title="内存回收(gc) 发生的场景和java命令查看oom的方法"></a>内存回收(gc) 发生的场景和java命令查看oom的方法</h3><p>总结起来是四个区域：堆，栈，matespace，堆外</p>
<p><a href="https://cloud.tencent.com/developer/article/1730910" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1730910</a></p>
<p><a href="https://xie.infoq.cn/article/74d7449272c21dd9f8d706957" target="_blank" rel="noopener">https://xie.infoq.cn/article/74d7449272c21dd9f8d706957</a></p>
<h4 id="jvm-oom-后服务还能运行吗"><a href="#jvm-oom-后服务还能运行吗" class="headerlink" title="jvm oom 后服务还能运行吗"></a>jvm oom 后服务还能运行吗</h4><p><a href="https://heapdump.cn/article/1818321" target="_blank" rel="noopener">OOM异常会导致JVM退出吗？</a><br><a href="https://www.cnblogs.com/pluto-charon/p/14792515.html" target="_blank" rel="noopener">JVM内存溢出后服务还能运行吗</a><br><a href="https://segmentfault.com/a/1190000020940733" target="_blank" rel="noopener">OOM会不会导致JVM崩溃</a><br><a href="https://heapdump.cn/article/670585" target="_blank" rel="noopener">OOM 后我如何分析解决的原创</a></p>
<h3 id="class-loader-类加载"><a href="#class-loader-类加载" class="headerlink" title="class loader(类加载)"></a>class loader(类加载)</h3><h4 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h4><p><img src="https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20220320172640.png" alt="20220320172640"></p>
<p>参考：<a href="https://juejin.cn/post/6931972267609948167#comment" target="_blank" rel="noopener">https://juejin.cn/post/6931972267609948167#comment</a></p>
<h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><h4 id="哪些组件破坏了双亲委派机制"><a href="#哪些组件破坏了双亲委派机制" class="headerlink" title="哪些组件破坏了双亲委派机制"></a>哪些组件破坏了双亲委派机制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jdbc tomcat spring破坏了双亲委派机制</span><br><span class="line"></span><br><span class="line">为什么Tomcat要破坏双亲委派</span><br><span class="line">我们知道，Tomcat是web容器，那么一个web容器可能需要部署多个应用程序。</span><br><span class="line">不同的应用程序可能会依赖同一个第三方类库的不同版本，但是不同版本的类库中某一个类的全路径名可能是一样的。</span><br><span class="line">如多个应用都要依赖hollis.jar，但是A应用需要依赖1.0.0版本，但是B应用需要依赖1.0.1版本。这两个版本中都有一个类是com.hollis.Test.class。</span><br><span class="line">如果采用默认的双亲委派类加载机制，那么是无法加载多个相同的类。</span><br><span class="line">所以，Tomcat破坏双亲委派原则，提供隔离的机制，为每个web容器单独提供一个WebAppClassLoader加载器。</span><br><span class="line">Tomcat的类加载机制：为了实现隔离性，优先加载 Web 应用自己定义的类，所以没有遵照双亲委派的约定，每一个应用自己的类加载器——WebAppClassLoader负责加载本身的目录下的class文件，加载不到时再交给CommonClassLoader加载，这和双亲委派刚好相反。</span><br></pre></td></tr></table></figure>
<p><a href="https://enfangzhong.github.io/2019/12/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">https://enfangzhong.github.io/2019/12/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</a></p>
<p><a href="https://juejin.cn/post/6916314841472991239" target="_blank" rel="noopener">https://juejin.cn/post/6916314841472991239</a></p>
<h3 id="对象内存布局-and-CAS"><a href="#对象内存布局-and-CAS" class="headerlink" title="对象内存布局 and CAS"></a>对象内存布局 and CAS</h3><p><a href="https://www.bilibili.com/video/BV1xK4y1C7aT?p=3&amp;spm_id_from=pageDriver" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1xK4y1C7aT?p=3&amp;spm_id_from=pageDriver</a></p>
<h3 id="compressed-class-pointer"><a href="#compressed-class-pointer" class="headerlink" title="compressed class pointer"></a>compressed class pointer</h3><p><a href="https://www.bilibili.com/video/BV1xK4y1C7aT?p=3&amp;spm_id_from=pageDriver" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1xK4y1C7aT?p=3&amp;spm_id_from=pageDriver</a><br><a href="https://stuefe.de/posts/metaspace/what-is-compressed-class-space/" target="_blank" rel="noopener">https://stuefe.de/posts/metaspace/what-is-compressed-class-space/</a></p>
<h3 id="Java8-新特性教程"><a href="#Java8-新特性教程" class="headerlink" title="Java8 新特性教程"></a>Java8 新特性教程</h3><h4 id="HotSpot"><a href="#HotSpot" class="headerlink" title="HotSpot"></a>HotSpot</h4><p>Removal of PermGen. </p>
<h4 id="Java-编程语言"><a href="#Java-编程语言" class="headerlink" title="Java 编程语言"></a>Java 编程语言</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Lambda 表达式是一个新的语言特性</span><br><span class="line">接口中允许添加默认方法</span><br><span class="line">Parallel Array Sorting</span><br><span class="line">Standard Encoding and Decoding Base64</span><br></pre></td></tr></table></figure>
<h4 id="Date-API-日期相关API"><a href="#Date-API-日期相关API" class="headerlink" title="Date API(日期相关API)"></a>Date API(日期相关API)</h4><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">针对存在键冲突的 HashMap 的性能改进</span><br><span class="line">新的java.util.stream包中的类提供了一个 Stream API</span><br></pre></td></tr></table></figure>
<h4 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Classes and interfaces have been added to the java.util.concurrent package.</span><br><span class="line">Methods have been added to the java.util.concurrent.ConcurrentHashMap class to support aggregate operations based on the newly added streams facility and lambda expressions.</span><br><span class="line">Classes have been added to the java.util.concurrent.atomic package to support scalable updatable variables.</span><br><span class="line">Methods have been added to the java.util.concurrent.ForkJoinPool class to support a common pool.</span><br><span class="line">The java.util.concurrent.locks.StampedLock class has been added to provide a capability-based lock with three modes for controlling read/write access.</span><br></pre></td></tr></table></figure>
<h4 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The jjs command is provided to invoke the Nashorn engine.</span><br><span class="line">The java command launches JavaFX applications.</span><br><span class="line">The java man page has been reworked.</span><br><span class="line">The jdeps command-line tool is provided for analyzing class files.</span><br><span class="line">Java Management Extensions (JMX) provide remote access to diagnostic commands.</span><br><span class="line">The jarsigner tool has an option for requesting a signed time stamp from a Time Stamping Authority (TSA).</span><br></pre></td></tr></table></figure>
<p><a href="https://www.oracle.com/cn/java/technologies/javase/8-whats-new.html" target="_blank" rel="noopener">https://www.oracle.com/cn/java/technologies/javase/8-whats-new.html</a><br><a href="https://www.oracle.com/java/technologies/javase/8-whats-new.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase/8-whats-new.html</a></p>
<h3 id="volatile-可见性和禁止指令重排"><a href="#volatile-可见性和禁止指令重排" class="headerlink" title="volatile 可见性和禁止指令重排"></a>volatile 可见性和禁止指令重排</h3><ol>
<li>volatile 可见性</li>
</ol>
<p>volatile 可见性在 cpu层面是通过<strong>缓存一致性协议</strong>实现的。缓存一致性协议简单说：一个 cpu 改了某一个缓存行的变量值，其他的 cpu 想读这个变量值，必须先刷新缓存行后(从主存更新)，再读取</p>
<p>缓存行 (Cache Line) 是 CPU Cache 中的最小单位，一个缓存行的大小通常是 64 字节（这取决于 CPU），并且它有效地引用主内存中的一块地址。一个 Java 的 long 类型是 8 字节，因此在一个缓存行中可以存 8 个 long 类型的变量。</p>
<p>cpu级的数据一致性是以cache line为单位的</p>
<p><a href="https://www.bilibili.com/video/BV1xK4y1C7aT?p=5&amp;spm_id_from=pageDriver" target="_blank" rel="noopener">P5 4-内存屏障的基本概念</a> 38分钟：缓存行 缓存一致性协议 60分钟：乱序执行</p>
<p><a href="https://segmentfault.com/q/1010000014178395" target="_blank" rel="noopener">Java:缓冲行(cache line)的一些问题</a></p>
<ol start="2">
<li>volatile 禁止指令重排</li>
</ol>
<p>DCL(double check lock)需不需要volatile? 答案：需要，new一个对象时使用三条指令，指令二和指令三重排序了，导致用户会使用半初始化的对象</p>
<p><img src="https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20210818232422.png" alt="20210818232422"></p>
<p><a href="https://www.bilibili.com/video/BV1xK4y1C7aT/?p=6&amp;vd_source=c3e9801497e408c0e02a3ddb59c2d64e" target="_blank" rel="noopener">volatile如何应用到singlten单例模式中-7分钟</a></p>
<p>解决指令重排的方案：变量加volatile来禁止指令重排。<br>那么问题又来了，volatile是怎么做到禁止指令重排的呢。<br>答案是：JSR内存屏障。当volatile修饰一个对象时，new前后加了xxBarrier。 NOTE: 这是一个规范，实际上jvm不是这么实现的，实际是通过 lock 实现的(通过hotspot源码的bytecodeinterpreter.cpp可以看到)</p>
<p><img src="https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20210819001418.png" alt="20210819001418"></p>
<ol start="3">
<li>总结：jvm 层面是用的是屏障xxBarrier，而 cpu 层面用的是缓存行 cache line。</li>
</ol>
<p>两者的关系：<br>volatile用于解决缓存一致性问题，因为volatile实际上只是保证了对CPU缓存的操作立即flush到内存，此时的flush依然是以缓存行为单位的，也即你对某缓存行中的单个变量的volatile实际上是应用到了整个缓存行的所有变量，进而会有不同变量的不必要的操作同步，影响性能，此时便需要解决这个问题。</p>
<h3 id="volatile在jvm中的实现代码-bytecodeinterpreter-cpp"><a href="#volatile在jvm中的实现代码-bytecodeinterpreter-cpp" class="headerlink" title="volatile在jvm中的实现代码 bytecodeinterpreter.cpp"></a>volatile在jvm中的实现代码 bytecodeinterpreter.cpp</h3><p><a href="https://www.bilibili.com/video/BV1xK4y1C7aT?p=7" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1xK4y1C7aT?p=7</a> 13分钟</p>
<h2 id="java锁"><a href="#java锁" class="headerlink" title="java锁"></a>java锁</h2><h3 id="sychronized"><a href="#sychronized" class="headerlink" title="sychronized"></a>sychronized</h3><h4 id="sychronized原理，字节码层级的支持entermonitor-exitmonitor-编译层级的支持lock-cmpxchg指令"><a href="#sychronized原理，字节码层级的支持entermonitor-exitmonitor-编译层级的支持lock-cmpxchg指令" class="headerlink" title="sychronized原理，字节码层级的支持entermonitor exitmonitor; 编译层级的支持lock cmpxchg指令"></a>sychronized原理，字节码层级的支持entermonitor exitmonitor; 编译层级的支持lock cmpxchg指令</h4><p><a href="https://www.bilibili.com/video/BV1xK4y1C7aT?p=5&amp;spm_id_from=pageDriver" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1xK4y1C7aT?p=5&amp;spm_id_from=pageDriver</a> 14分钟</p>
<h4 id="sychronized锁升级过程"><a href="#sychronized锁升级过程" class="headerlink" title="sychronized锁升级过程"></a>sychronized锁升级过程</h4><ol>
<li>锁升级五个阶段：无锁 偏向锁 轻量级锁 自旋锁 重量级锁<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">每一个线程在准备获取共享资源时都会执行如下逻辑：</span><br><span class="line">当线程进入同步代码块时，</span><br><span class="line">第零步，这时是无锁状态，</span><br><span class="line">第一步，此时，线程会检查 MarkWord 里面是否存放有自己的 ThreadId ，如果是，标识位置为 01 ，表示当前线程是处于 “偏向锁”； </span><br><span class="line">第二步，如果 MarkWord 不是自己的 ThreadId ，进行锁升级。此时，此线程根据 MarkWord 里面现有的 ThreadId ，通知该线程暂停，</span><br><span class="line">该线程将 Markword 的内容置为空。然后，两个线程都想获得锁，</span><br><span class="line">第三步，两个线程会在自己的栈帧中建立一个 Lock Record 的空间，两个线程都会通过 CAS 方式尝试将自己的 Mark Word 更新为指向自己栈的 LockRecord 的指针；</span><br><span class="line">第四步，第三步中成功执行 CAS 的获得资源的线程获取到锁，将标识位置为 00 ；失败的线程则进入自旋；</span><br><span class="line">第五步，自旋的线程在自旋过程中，成功获得资源(即之前获的资源的线程执行完成并释放了共享资源)，则整个状态依然处于 轻量级锁的状态，如果自旋失败 </span><br><span class="line">第六步，进入重量级锁的状态，这个时候，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><a href="https://www.bilibili.com/video/BV1xK4y1C7aT?p=4&amp;vd_source=c3e9801497e408c0e02a3ddb59c2d64e" target="_blank" rel="noopener">锁升级过程</a></p>
<p><img src="https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20220601202445.png" alt=""></p>
<ol start="2">
<li><p>锁升级是什么时候发生的？<br>偏向锁：一个线程获取锁时会由无锁升级为偏向锁<br>自旋锁：当产生线程竞争时由偏向锁升级为自旋锁,想象一下 while(true) ;<br>重量级锁：当线程竞争到达一定数量或超过一定时间时，晋升为重量级锁</p>
</li>
<li><p>锁升级代码实践</p>
</li>
</ol>
<p><a href="https://www.bilibili.com/video/BV1xK4y1C7aT?p=3&amp;vd_source=c3e9801497e408c0e02a3ddb59c2d64e" target="_blank" rel="noopener">代码加锁实例演示</a> </p>
<h4 id="sychronized有锁升级，那么有锁降级吗？"><a href="#sychronized有锁升级，那么有锁降级吗？" class="headerlink" title="sychronized有锁升级，那么有锁降级吗？"></a>sychronized有锁升级，那么有锁降级吗？</h4><p>锁降级如果是指：sychronized的锁降级，那么是没有的；但是锁降级如果指的是读写锁(ReentantReadWriteLock)的降级，那么是有的。指的是写锁降级为读锁的过程。详见ReentantReadWriteLock的部分</p>
<h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><h4 id="ReentantLock"><a href="#ReentantLock" class="headerlink" title="ReentantLock"></a>ReentantLock</h4><h5 id="Reentantlock的实现原理"><a href="#Reentantlock的实现原理" class="headerlink" title="Reentantlock的实现原理"></a>Reentantlock的实现原理</h5><p>线程1来了，尝试获取锁，如果cas成功，获取锁成功，返回；如果获取锁失败，排队等待。在哪排队：一个队列。如何排队，</p>
<h5 id="Condition实现原理"><a href="#Condition实现原理" class="headerlink" title="Condition实现原理"></a>Condition实现原理</h5><p><a href="https://www.cnblogs.com/bendantuohai/p/4738792.html" target="_blank" rel="noopener">Condition的优点</a></p>
<h4 id="ReentantReadWriteLock"><a href="#ReentantReadWriteLock" class="headerlink" title="ReentantReadWriteLock"></a>ReentantReadWriteLock</h4><p><a href="https://bestzuo.cn/posts/1665595927.html" target="_blank" rel="noopener">ReentrantReadWriteLock读写锁源码分析</a></p>
<ol>
<li><p>ReentantReadWriteLock的实现原理</p>
</li>
<li><p>ReentantReadWriteLock使用实例</p>
</li>
<li><p>ReentantReadWriteLock锁降级<br>锁降级发生在读写锁中，写锁降级读锁的过程。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">问：为什么可以锁降级，也就是说，为什么释放写锁之前可以获取读锁？</span><br><span class="line">答：你既然拿到写锁了，其他线程就没法拿到读锁或者写锁，你再（在拿到写锁的线程中）拿读锁，其实不会和其他线程的写锁发送冲突的，因为你拿到写锁到写锁释放的这段时间，其他线程是无法拿到任何锁的。</span><br><span class="line"></span><br><span class="line">问：为什么不可以锁升级，即为什么获取读锁之后不能再获取写锁？</span><br><span class="line">答：锁升级就没法做到读写互斥了。两个线程都拿到了读锁，前一个线程升级成写锁，后一个线程的读锁又没释放，所以就没法做到读写互斥了。</span><br><span class="line"></span><br><span class="line">问：为什么要进行锁降级</span><br><span class="line">锁降级中，读锁的获取的目的是 “为了保证数据的可见性”。而得到这个结论的依据是 “如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程（记作线程 T）获取了写锁并修改了数据，那么当前线程无法感知线程 T 的数据更新”。</span><br><span class="line">这里貌似有个漏洞：如果另一个线程获取了写锁（并修改了数据），那么这个锁就被独占了，没有任何其他线程可以读到数据，更不用谈 “感知数据更新”。</span><br><span class="line"></span><br><span class="line">作者认为，锁降级说白了就是写锁的一种特殊重入机制。通过这种重入，可以减少一步流程——释放写锁后再次获取读锁。</span><br><span class="line"></span><br><span class="line">使用了锁降级，就可以减去释放写锁的步骤。直接获取读锁。效率更高。而且没有线程争用。和 “可见性” 并没有关系。我个人通过阅读源码也觉得该作者的解释更加合理。</span><br><span class="line"></span><br><span class="line">锁降级就是一种特殊的锁重入机制，JDK 使用 先获取写入锁，然后获取读取锁，最后释放写入锁 这个步骤，是为了提高获取锁的效率，而不是所谓的可见。</span><br></pre></td></tr></table></figure>
<h3 id="synchronized和Lock对比"><a href="#synchronized和Lock对比" class="headerlink" title="synchronized和Lock对比"></a>synchronized和Lock对比</h3><h4 id="Lock相较于Synchronized优势"><a href="#Lock相较于Synchronized优势" class="headerlink" title="Lock相较于Synchronized优势"></a>Lock相较于Synchronized优势</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如下：</span><br><span class="line">可公平：可公平可不公平</span><br><span class="line">可中断获取锁：使用synchronized关键字获取锁的时候，如果线程没有获取到被阻塞了，那么这个时候该线程是不响应中断(interrupt)的，而使用Lock.lockInterruptibly()获取锁时被中断，线程将抛出中断异常。</span><br><span class="line">可非阻塞获取锁：使用synchronized关键字获取锁时，如果没有成功获取，只有被阻塞，而使用Lock.tryLock()获取锁时，如果没有获取成功也不会阻塞而是直接返回false。</span><br><span class="line">可限定获取锁的超时时间：使用Lock.tryLock(long time, TimeUnit unit)。</span><br><span class="line">同一个所对象上可以有多个等待队列（Conditin，类似于Object.wait()，支持公平锁模式）</span><br></pre></td></tr></table></figure>
<h4 id="Lock-vs-Synchronized分别适用什么样的场景"><a href="#Lock-vs-Synchronized分别适用什么样的场景" class="headerlink" title="Lock vs Synchronized分别适用什么样的场景"></a>Lock vs Synchronized分别适用什么样的场景</h4><h4 id="Lock-vs-Synchronized知识整体参考："><a href="#Lock-vs-Synchronized知识整体参考：" class="headerlink" title="Lock vs Synchronized知识整体参考："></a>Lock vs Synchronized知识整体参考：</h4><p><a href="https://tech.youzan.com/javasuo-de-na-xie-shi-er/" target="_blank" rel="noopener">Java锁的那些事儿</a><br><a href="https://jishuin.proginn.com/p/763bfbd345d9" target="_blank" rel="noopener">Synchronized和 ReentrantLock到底怎么选，我蒙了</a></p>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><h4 id="AQS-内部的关键是什么"><a href="#AQS-内部的关键是什么" class="headerlink" title="AQS 内部的关键是什么"></a>AQS 内部的关键是什么</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">AQS的核心：一个双向队列(双向的FIFO) 和一个同步状态(0:可用，1:被占用)</span><br><span class="line">简单来说，AQS 的实现依赖内部的同步队列（FIFO 双向队列），如果当前线程获取同步状态失败，AQS 会将该线程以及等待状态等信息构造成一个 Node，将其加入同步队列的尾部，同时阻塞当前线程，当同步状态释放时，唤醒队列的头节点。</span><br><span class="line"></span><br><span class="line">AQS的双向队列是由封装了thread和节点状态waitStatus的Node对象组成</span><br><span class="line">其节点状态waitStatus的枚举值及含义如下：</span><br><span class="line">/** </span><br><span class="line"> * waitStatus value to indicate thread has cancelled </span><br><span class="line"> * =&gt; waitStatus &gt; 0 说明此节点的线程是已取消状态</span><br><span class="line"> * </span><br><span class="line"> * 详细说明：This node is cancelled due to timeout or interrupt. Nodes never leave this state. In particular, a thread with cancelled node never again blocks</span><br><span class="line"> */</span><br><span class="line">static final int CANCELLED =  1;</span><br><span class="line"></span><br><span class="line">/** waitStatus value to indicate successor&apos;s thread needs unparking  </span><br><span class="line"> *  =&gt; 表明当前节点的继承者successor需要启动，等同于当前线程的继承者successor已经准备好了，就等当前线程资源释放了，它就可以启动了 </span><br><span class="line"> */</span><br><span class="line">/** 详细说明：</span><br><span class="line"> *  The successor of this node is (or will soon be) blocked (via park), so the current node must unpark its successor when it releases or cancels. </span><br><span class="line"> *  To avoid races, acquire methods must first indicate they need a signal, then retry the atomic acquire, and then, on failure, block.</span><br><span class="line"> *  注释：successor of this node 即 node.next</span><br><span class="line"> */</span><br><span class="line">static final int SIGNAL    = -1;</span><br><span class="line"></span><br><span class="line">/** waitStatus value to indicate thread is waiting on condition</span><br><span class="line"> *  =&gt; 表示节点在等待队列中，节点线程等待唤醒</span><br><span class="line"> */</span><br><span class="line">static final int CONDITION = -2;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * waitStatus value to indicate the next acquireShared should unconditionally propagate</span><br><span class="line"> * =&gt; 当前线程处在SHARED情况下，该字段才会使用</span><br><span class="line"> */</span><br><span class="line">/** 详细说明：</span><br><span class="line"> * A releaseShared should be propagated to other nodes.                                        </span><br><span class="line"> * his is set (for head node only) in doReleaseShared to ensure propagation continues, even if other operations have since intervened.</span><br><span class="line"> */ </span><br><span class="line">static final int PROPAGATE = -3;</span><br></pre></td></tr></table></figure>
<p>自总结学习AQS步骤</p>
<ol>
<li>看大牛的文章</li>
<li>debug源码 使用合适的demo小例子很重要</li>
<li>看看开源组件如何使用的AQS</li>
<li>自己找场景使用</li>
</ol>
<p>带着疑问debug</p>
<ol>
<li>FIFO队列中的head这个虚节点waitStatus的值是什么</li>
<li>FIFO队列中的node节点的waitStatus的值，在节点加入队列时是什么，然后又会在什么时候更新</li>
</ol>
<p>答案的核心都在这两个方法中： acquireQueued (addWaiter(Node.EXCLUSIVE), arg)<br>节点在加到队列时的waitStatus值都是0，此操作在addWaiter(Node.EXCLUSIVE) 方法中。而节点的状态的更新在 acquireQueued(node, arg) 方法中。node节点是包含当前线程的节点，addWaiter将node放入队列。随后 acquireQueued 方法会看看队列中的此节点能否获取到锁，不能获取时就会更新此节点的waitStatus的值。具体在 acquireQueued 方法中的 shouldParkAfterFailedAcquire(p, node) 方法。<br>注意：<br>1.参数中的 p 是 node 的前继节点，即 p = node.pre。<br>2.shouldParkAfterFailedAcquire 改的是 p 节点的waitStatus 值。从0更新到SIGNAL(-1)。然后，node 节点的线程就会通过 parkAndCheckInterrupt() 方法 LockSupport.park(this) 挂起了。那么问题又来了，它啥时候会被唤醒呢。<br>小结下：此时 node 节点的 waitStatus 值还是0，而 p(p = node.pre) 节点的 waitStatus 值为 SIGNAL(-1)。</p>
<p><a href="https://www.cnblogs.com/wang-meng/p/12816829.html" target="_blank" rel="noopener">【深入AQS原理】我画了35张图就是为了让你深入 AQS</a><br><a href="https://javadoop.com/2017/07/20/AbstractQueuedSynchronizer-2" target="_blank" rel="noopener">一行一行源码分析清楚 AbstractQueuedSynchronizer</a></p>
<h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><p><a href="https://javadoop.com/post/java-concurrent-queue" target="_blank" rel="noopener">LinkedBlockingQueue</a></p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h4 id="属性值的含义"><a href="#属性值的含义" class="headerlink" title="属性值的含义"></a>属性值的含义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">初始值 16的原因：1，必须是2的幂次，这时候 (n - 1) &amp; hash 等价于 n%hash，与运算（&amp;）比取余（%）运算效率高，与运更高效。算散列最均匀；如果太小，4或者8，扩容比较频繁；如果太大，32或者64甚至太大，又占用内存空间</span><br><span class="line"></span><br><span class="line">长度16或其他2的幂次方，Length - 1的值的二进制所有的位均为1，这种情况下，Index的结果等于hashCode的最后几位。只要输入的hashCode本身符合均匀分布，Hash算法的结果就是均匀的。</span><br><span class="line"></span><br><span class="line">[HashMap中为什么数组的长度为2的幂次方](https://www.jianshu.com/p/7cf2d6f1096b)</span><br><span class="line"></span><br><span class="line">负载因子0.75的原因。关键词：牛顿二项式基础前确定的0.75，在此基础上确定的哈希表变红黑树的阈值 8</span><br><span class="line">哈希表变红黑树阈值 8的原因:</span><br><span class="line">核心：树化的阈值是8，加载系数是0.75的时候，出现树化的概率为0.00000006。关键词：泊松分布。</span><br><span class="line">泊松分布论证了：在hash桶中，同时使用0.75 作为加载因子的时候，节点个数出现的频率遵循泊松分布。</span><br><span class="line"></span><br><span class="line">如下给出了桶中元素个数和概率的对照表：</span><br><span class="line">0: 0.60653066</span><br><span class="line">1: 0.30326533</span><br><span class="line">2: 0.07581633</span><br><span class="line">3: 0.01263606</span><br><span class="line">4: 0.00157952</span><br><span class="line">5: 0.00015795</span><br><span class="line">6: 0.00001316</span><br><span class="line">7: 0.00000094</span><br><span class="line">8: 0.00000006</span><br><span class="line">more: less than 1 in ten million</span><br><span class="line"></span><br><span class="line">在长度为16的HashMap中放入12（0.75*length）个数据时，hash桶中某一个槽slot中存放了8个节点的概率是0.00000006。所以，当槽slot的节点大于等于8个的时候，就可以从链表node转换为treenode，其性价比是值得的。</span><br></pre></td></tr></table></figure>
<p><a href="http://www.west999.com/info/html/chengxusheji/Javajishu/20190908/4658856.html" target="_blank" rel="noopener">面试加分项-HashMap源码中这些常量的设计目的</a><br><a href="https://www.cnblogs.com/lanqingzhou/p/14360195.html" target="_blank" rel="noopener">hashmap的泊松分布，二项式分布？</a></p>
<h4 id="HashMap多线程下不安全的原因"><a href="#HashMap多线程下不安全的原因" class="headerlink" title="HashMap多线程下不安全的原因"></a>HashMap多线程下不安全的原因</h4><ol>
<li>java8以前的版本</li>
</ol>
<p>rehash时可能出现链表成环<br><a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="noopener">疫苗：JAVA HASHMAP的死循环</a><br><a href="https://zhuanlan.zhihu.com/p/345237682" target="_blank" rel="noopener">为什么HashMap线程不安全？</a></p>
<ol start="2">
<li>java8的版本<br>因为 JDK1.8 已经修复了rehash时可能出现链表成环的问题，但是依然不建议在多线程环境下使用 HashMap！</li>
</ol>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><h4 id="ConcurrentHashMap是如何做到线程安全的，他的数据结构是什么"><a href="#ConcurrentHashMap是如何做到线程安全的，他的数据结构是什么" class="headerlink" title="ConcurrentHashMap是如何做到线程安全的，他的数据结构是什么"></a>ConcurrentHashMap是如何做到线程安全的，他的数据结构是什么</h4><p><strong>java8下，数据结构和HashMap一样。做到线程安全的的办法是通过 CAS + synchronized</strong><br>ConcurrentHashMap 中 synchronized 只锁定当前链表或红黑二叉树的首节点，只要节点 hash 不冲突，就不会产生并发，相比 JDK1.7 的 ConcurrentHashMap 效率又提升了 N 倍！<br><a href="http://www.justdojava.com/2019/12/18/java-collection-15.1" target="_blank" rel="noopener">面试必问之 ConcurrentHashMap 线程安全的具体实现方式</a></p>
<h4 id="ConcurrentHashMap真的安全吗？"><a href="#ConcurrentHashMap真的安全吗？" class="headerlink" title="ConcurrentHashMap真的安全吗？"></a>ConcurrentHashMap真的安全吗？</h4><p><a href="https://developer.aliyun.com/article/776568" target="_blank" rel="noopener">https://developer.aliyun.com/article/776568</a></p>
<h2 id="threadLocal"><a href="#threadLocal" class="headerlink" title="threadLocal"></a>threadLocal</h2><p><a href="https://www.bilibili.com/video/BV1fA411b7SX/" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1fA411b7SX/</a> 46分钟<br><a href="https://www.bilibili.com/video/BV1xK4y1C7aT?p=8" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1xK4y1C7aT?p=8</a> 20分钟<br><a href="https://segmentfault.com/a/1190000022663697" target="_blank" rel="noopener">万字图文深度解析ThreadLocal</a></p>
<p>-&gt; Question：<br>C. threadLocalMap 的key为啥是threadLocal对象呢，用threadId可以吗<br>E. 为什么ThreadLocalMap 如何解决hash碰撞的呢：采用(线性探测法)开放地址法来解决哈希冲突? 为啥不用hashmap的链表法<br>D. threadLocal 的魔数0x61c88647的原理<br>B. threadLocalMap 的 Entry 对象为啥是弱引用的呢<br>F. threadLocal 会发生内存泄漏吗<br>H. 代码实践查看gc 后Entry的key 和value是否被回收<br>M. threadLocal 过期key的清理机制是什么？探测(触发)式清理：replaceStaleEntry；启发式清理：cleanSomeSlots<br>N. threadLocal缺点，InheritableThreadLocal是什么，TransmittableThreadLocal是什么<br>threadLocal缺点是不能在线程间传递数据，InheritableThreadLocal可以在父子线程间传递数据，TransmittableThreadLocal可以在线程池中的线程间传递数据，是Alibaba开源的</p>
<p>G. ThreadLocalMap 和 HashMap 的区别</p>
<ol>
<li>HashMap 的数据结构是数组+链表，而ThreadLocalMap的数据结构仅仅是数组</li>
<li>HashMap 是通过链地址法解决hash 冲突的问题，而ThreadLocalMap 是通过开放地址法来解决hash 冲突的问题</li>
<li>HashMap 里面的Entry 内部类的引用都是强引用，而ThreadLocalMap里面的Entry 内部类中的key 是弱引用，value 是强引用 </li>
</ol>
<p>-&gt; Answer Question:</p>
<h3 id="C-threadLocalMap-的key为啥是threadLocal对象呢，用threadId可以吗"><a href="#C-threadLocalMap-的key为啥是threadLocal对象呢，用threadId可以吗" class="headerlink" title="C. threadLocalMap 的key为啥是threadLocal对象呢，用threadId可以吗"></a>C. threadLocalMap 的key为啥是threadLocal对象呢，用threadId可以吗</h3><p>使用threadId无法区分一个线程多个threadLocal的情况 </p>
<h3 id="E-为什么ThreadLocalMap-采用-线性探测法-开放地址法来解决哈希冲突，为啥不用-Hashmap-的链表法"><a href="#E-为什么ThreadLocalMap-采用-线性探测法-开放地址法来解决哈希冲突，为啥不用-Hashmap-的链表法" class="headerlink" title="E. 为什么ThreadLocalMap 采用(线性探测法)开放地址法来解决哈希冲突，为啥不用 Hashmap 的链表法"></a>E. 为什么ThreadLocalMap 采用(线性探测法)开放地址法来解决哈希冲突，为啥不用 Hashmap 的链表法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap 采用开放地址法(线性探测法)原因</span><br><span class="line">线性探测法一是简单，二是节省内存，三是通过 0x61c88647魔术的使用，使得hash值分布很均匀。同时 ThreadLocal 往往存放的数据量不会特别大。简单的意思包含扩容操作的成本，扩容时重新散列数据的成本</span><br><span class="line">1.ThreadLocal 中看到一个属性 HASH_INCREMENT = 0x61c88647，0x61c88647 是一个神奇的数字，让哈希码能均匀的分布在2的N次方的数组里，即 Entry[] table，关于这个神奇的数字 google 有很多解析，这里就不重复说了</span><br><span class="line">2.ThreadLocal 往往存放的数据量不会特别大 (而且key 是弱引用又会被垃圾回收，及时让数据量更小)，这个时候开放地址法简单的结构会显得更省空间，同时数组的查询效率也是非常高，加上第一点的保障，冲突概率也低 </span><br><span class="line"></span><br><span class="line">链地址法和线性探测法的优缺点</span><br><span class="line">线性探测法：</span><br><span class="line">1.容易产生堆积问题，不适于大规模的数据存储。</span><br><span class="line">2.散列函数的设计对冲突会有很大的影响，插入时可能会出现多次冲突的现象。</span><br><span class="line">3.删除的元素是多个冲突元素中的一个，需要对后面的元素作处理，实现较复杂。</span><br><span class="line"></span><br><span class="line">链地址法：</span><br><span class="line">1.处理冲突简单，且无堆积现象，平均查找长度短。</span><br><span class="line">2.链表中的结点是动态申请的，适合构造表不能确定长度的情况。</span><br><span class="line">3.删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。</span><br><span class="line">4.指针需要额外的空间，故当结点规模较小时，线性探测法较为节省空间。</span><br></pre></td></tr></table></figure>
<p><a href="https://juejin.cn/post/6844903974454329358" target="_blank" rel="noopener">被大厂面试官连环炮轰炸的ThreadLocal（吃透源码的每一个细节和设计原理）</a></p>
<h3 id="D-threadLocal-的魔数0x61c88647"><a href="#D-threadLocal-的魔数0x61c88647" class="headerlink" title="D. threadLocal 的魔数0x61c88647"></a>D. threadLocal 的魔数0x61c88647</h3><p>0x61c88647 的二进制为：1100001110010001000011001000111<br>0x61c88647 的十进制为：1640531527</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HASH_INCREMENT = 0x61c88647; 目的是使：ThreadLocal对象的threadLocalHashCode较为均匀地分布在2的幂大小的数组中。</span><br><span class="line">即：int h = k.threadLocalHashCode &amp; (newLen - 1) 使h的值更均匀的分布在Entry[] table的数组中。</span><br><span class="line"></span><br><span class="line">进一步提问：why?: 为什么0x61c88647会使得在数组中分布更均匀呢</span><br><span class="line">answer:</span><br><span class="line">0x61c88647 = 1640531527 ≈ 2 ^ 32 * (1 - 1 / φ), φ = (√5 + 1) ÷ 2, it is an another Golden ratio Num of 32 bits.</span><br><span class="line">https://stackoverflow.com/questions/38994306/what-is-the-meaning-of-0x61c88647-constant-in-threadlocal-java</span><br><span class="line">https://juejin.cn/post/6844903648800014349 魔数部分</span><br><span class="line"></span><br><span class="line">0x61c88647与斐波那契散列有关，是斐波那契散列的一个例子，也叫黄金分割数，0x61c88647对应的十进制为1640531527。二进制为1100001110010001000011001000111(31位)</span><br></pre></td></tr></table></figure>
<h3 id="B-threadLocalMap-的Entry对象为啥是弱引用的呢"><a href="#B-threadLocalMap-的Entry对象为啥是弱引用的呢" class="headerlink" title="B. threadLocalMap 的Entry对象为啥是弱引用的呢"></a>B. threadLocalMap 的Entry对象为啥是弱引用的呢</h3><p>是出于 GC 考虑，当某个 ThreadLocal 已经没有强引用指向时，它被 GC 回收，那么ThreadLocalMap 里对应的 Entry 的键值会随之失效<br>如果key是强引用，即使tl=null，但key的引用依然指向ThreadLocal对象，所以会造成内存泄漏，而使用弱引用则不会。</p>
<h3 id="F-threadLocal-会发生内存泄漏吗"><a href="#F-threadLocal-会发生内存泄漏吗" class="headerlink" title="F. threadLocal 会发生内存泄漏吗"></a>F. threadLocal 会发生内存泄漏吗</h3><p>ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用引用他，那么系统gc的时候，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：<br>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value。永远无法回收，造成内存泄露。</p>
<p>一个具体的例子就是：如果线程是线程池的， 在线程执行完代码的时候并没有结束，只是归还给线程池，这个时候ThreadLocalMap 和里面的元素是不会回收掉的，尤其value是大对象时，就会容易造成内存泄露。</p>
<p>从图中可以容易理解下<br>1.堆栈角度的对象引用图</p>
<p>2.线程角度的对象引用图</p>
<h3 id="H-代码实践查看gc-后Entry的key-和value是否被回收"><a href="#H-代码实践查看gc-后Entry的key-和value是否被回收" class="headerlink" title="H. 代码实践查看gc 后Entry的key 和value是否被回收"></a>H. 代码实践查看gc 后Entry的key 和value是否被回收</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://segmentfault.com/a/1190000022663697 的反射部分</span><br></pre></td></tr></table></figure>
<h3 id="M-threadLocal-过期key的清理机制是什么？探测-触发-式清理：replaceStaleEntry；启发式清理：cleanSomeSlots"><a href="#M-threadLocal-过期key的清理机制是什么？探测-触发-式清理：replaceStaleEntry；启发式清理：cleanSomeSlots" class="headerlink" title="M. threadLocal 过期key的清理机制是什么？探测(触发)式清理：replaceStaleEntry；启发式清理：cleanSomeSlots"></a>M. threadLocal 过期key的清理机制是什么？探测(触发)式清理：replaceStaleEntry；启发式清理：cleanSomeSlots</h3><p>探测式清理是以当前Entry 往后清理，遇到值为null则结束清理，属于线性探测清理。之前发生 Hash冲突 的Entry元素的位置应该更接近真实hash出来的位置。提升了查找的效率。这里探测式清理并不能全部清除数组中的过期元素，而是从传入的下标清理到第一个 Entry==null 为止。部分清除。<br>其余的部分，需要通过 启发式清理</p>
<p>启动式清理会从传入的下标 i 处，向后遍历。如果发现过期的Entry则再次触发探测式清理，并重置 n</p>
<h3 id="G-ThreadLocalMap和-HashMap的区别。ThreadLocalMap-和HashMap的功能类似，但是实现上却有很大的不同："><a href="#G-ThreadLocalMap和-HashMap的区别。ThreadLocalMap-和HashMap的功能类似，但是实现上却有很大的不同：" class="headerlink" title="G. ThreadLocalMap和 HashMap的区别。ThreadLocalMap 和HashMap的功能类似，但是实现上却有很大的不同："></a>G. ThreadLocalMap和 HashMap的区别。ThreadLocalMap 和HashMap的功能类似，但是实现上却有很大的不同：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 数据结构</span><br><span class="line">HashMap 的数据结构是数组+链表</span><br><span class="line">ThreadLocalMap的数据结构仅仅是数组</span><br><span class="line"></span><br><span class="line">2. 解决hash冲突的方法，为什么这么设计</span><br><span class="line">HashMap 是通过链地址法解决hash 冲突的问题</span><br><span class="line">ThreadLocalMap 是通过线性探测法(linear detection method)来解决hash 冲突的问题</span><br><span class="line"></span><br><span class="line">3. Entry 内部类的引用是否为强弱引用</span><br><span class="line">HashMap 里面的Entry 内部类的引用都是强引用</span><br><span class="line">ThreadLocalMap里面的Entry 内部类中的key 是弱引用，value 是强引用</span><br></pre></td></tr></table></figure>
<h2 id="线程安全的队列"><a href="#线程安全的队列" class="headerlink" title="线程安全的队列"></a>线程安全的队列</h2><p>如果我们要实现一个线程安全的队列有两种实现方式一种是使用阻塞算法，另一种是使用非阻塞算法。使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现，而非阻塞的实现方式则可以使用循环CAS的方式来实现</p>
<h4 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h4><p>…</p>
<h4 id="LinkedBlockingQueue-1"><a href="#LinkedBlockingQueue-1" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><p>…</p>
<h2 id="threadpoolExecutor-线程池"><a href="#threadpoolExecutor-线程池" class="headerlink" title="threadpoolExecutor 线程池"></a>threadpoolExecutor 线程池</h2><h3 id="线程池的执行流程"><a href="#线程池的执行流程" class="headerlink" title="线程池的执行流程"></a>线程池的执行流程</h3><pre><code>done
</code></pre><h3 id="线程池核心线程何时销毁"><a href="#线程池核心线程何时销毁" class="headerlink" title="线程池核心线程何时销毁"></a>线程池核心线程何时销毁</h3><p>当缓存队列中的任务都执行完了的时候，线程池中的线程数如果大于核心线程数，就销毁多出来的线程，直到线程池中的线程数等于核心线程数。此时这些线程就不会被销毁了，它们一直处于阻塞状态，等待新的任务到来。</p>
<p>详细参见：<a href="https://www.cnblogs.com/javastack/p/14923651.html" target="_blank" rel="noopener">线程池是如何重复利用空闲线程的</a></p>
<h3 id="几个核心问题"><a href="#几个核心问题" class="headerlink" title="几个核心问题"></a>几个核心问题</h3><ol>
<li><p>线程池的核心线程是如何保持一直在的<br>在 runWorker 方法中，再进入 getTask() 方法中，如果没有任务，队列就会阻塞。从而达到线程不回收，即保持一直存活着的。这也是为啥用阻塞队列的原因。可能你会说，用for自循环也可以实现，对的，但那样会一直占用CPU资源</p>
</li>
<li><p>线程池中的线程是如何重用的<br>答案在 runWorker 方法中</p>
</li>
</ol>
<p>线程之所以能达到复用，就是在当前线程执行的runWorker方法中有个while循环，while循环的第一个判断条件是执行当前线程关联的Worker对象中的任务，执行一轮后进入while循环的第二个判断条件getTask()，从任务队列中取任务，取这个任务的过程要么是一直阻塞的，要么是阻塞一定时间直到超时才结束的，超时到了的时候这个线程也就走到了生命的尽头。</p>
<p>然而在我们开始分析execute的时候，这个方法中的三个部分都会调用addWorker去执行任务，在addWorker方法中都会去新建一个线程来执行任务，这样的话是不是每次execute都是去创建线程了？事实上，复用机制跟线程池的阻塞队列有很大关系，我们可以看到，在execute在核心线程满了，但是队列不满的时候会把任务加入到队列中，一旦加入成功，之前被阻塞的线程就会被唤醒去执行新的任务，这样就不会重新创建线程了。</p>
<p>详细参见：<a href="https://www.cnblogs.com/javastack/p/14923651.html" target="_blank" rel="noopener">线程池是如何重复利用空闲线程的</a></p>
<h3 id="线程池使用注意事项"><a href="#线程池使用注意事项" class="headerlink" title="线程池使用注意事项"></a>线程池使用注意事项</h3><ol>
<li>一般建议是不同的业务使用不同的线程池，线程池间独立使用</li>
<li>正确配置线程池参数</li>
<li>别忘记给线程池命名</li>
</ol>
<h4 id="线程池设置多少合适呢"><a href="#线程池设置多少合适呢" class="headerlink" title="线程池设置多少合适呢"></a>线程池设置多少合适呢</h4><ul>
<li>cpu密集型的设置多少，io密集型的设置多少</li>
<li>❶ CPU密集型程序: CPU 核数（逻辑）+ 1 个线程数。<br>计算密集型的任务，通常很需要CPU资源。如果线程太多，就需要太多的上下文切换，上下文切换会很浪费CPU资源，降低了线程的执行时间。所以，对于计算密集型的任务，线程池核心线程数为：<strong>CPU 核数（逻辑）+ 1 个线程数。</strong></li>
</ul>
<p>CPU 密集型任务(N+1)： 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</p>
<ul>
<li><p>❷ I/O 密集型程序: 2N<br>I/O 密集型任务(2N)： 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</p>
</li>
<li><p>❸ 最佳线程数 = CPU核心数<em>(1/CPU利用率) = CPU核心数</em>(IO耗时/CPU耗时)</p>
</li>
<li><p>❹ 我怎么知道具体的 I/O耗时和CPU耗时呢？怎么查看CPU利用率？<br>APM(SkyWalking CAT zipkin)工具或者JDK自带的工具 VisualVM可以帮我们得到准确的数据，学会使用这类工具，也就可以结合理论，在调优的过程得到更优的线程个数了。</p>
</li>
</ul>
<p>Tips 具体的要结合机器是多少核心的，机器上有多少个服务，这些服务已占用了多少线程数。再加上本服务执行的任务类型，再通过APM查看具体的数值</p>
<p>参考：<br><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html" target="_blank" rel="noopener">Java线程池实现原理及其在美团业务中的实践</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3NjU3NTkwMQ==&amp;mid=2247505103&amp;idx=1&amp;sn=a041dbec689cec4f1bbc99220baa7219&amp;chksm=cf32b93df845302bfcbd4c5e9384a955bbc7e98f1de817949a080725408e2ff421f02f09ae89#rd" target="_blank" rel="noopener">如何设置线程池参数？美团给出了一个让面试官虎躯一震的回答</a></p>
<p><a href="https://yaoyuanyy.github.io/2022/06/10/ThreadPoolExecutor%E7%BB%86%E6%8A%A0%E6%BA%90%E7%A0%81/">ThreadPoolExecutor细抠源码</a></p>
<h3 id="关于线程池胡思乱想产生的问题"><a href="#关于线程池胡思乱想产生的问题" class="headerlink" title="关于线程池胡思乱想产生的问题"></a>关于线程池胡思乱想产生的问题</h3><p>todo   </p>
<ol>
<li>线程池中线程是如何回收的呢，假设现在任务已经用了最大线程数执行完了，队列里的任务也执行完了。按按照线程池的约定(假设核心线程不允许超时)，线程池会回收除了核心线程以外的线程。它是如何回收的呢</li>
</ol>
<ul>
<li>答案：此逻辑在<code>runWorker</code> 和 <code>getTask</code>方法中。具体为：每个<code>worker</code>执行完<code>firstTask</code> 后，会从队列中拿任务，这个队列是阻塞队列，如果此时线程池线程数大于<code>corePoolSize</code>，那么阻塞队列获取任务用的是<code>workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)</code> 方法，当在指定时间没有拿到任务就返回<code>null</code>，<code>runWorker</code>方法拿到<code>null</code> 就会退出<code>while</code> 循环，<code>runWorker</code> 方法在结束前执行 <code>workers.remove(w)</code>，从集合中删除，然后<code>runWorker</code> 方法所在的线程就结束了，线程池中自然就减少了一个线程。</li>
</ul>
<ol start="2">
<li>线程池中的任务是如何运行的。</li>
</ol>
<ul>
<li>答案：当一个任务通过execute方法放入线程池，在new Worker时会将Worker与Thread产生关联。<code>this.thread = getThreadFactory().newThread(this);</code>，相当于thread.runable = worker，所以，addWorker方法中执行 thread.start()方法时，会执行runable.run方法，即worker.run方法，<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">    runWorker(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this=worker，runWorker(worker)里会取到worker.firstTask。firstTask即是我们最开始的任务: firstTask.run()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="线程池运用不当导致的问题的实例"><a href="#线程池运用不当导致的问题的实例" class="headerlink" title="线程池运用不当导致的问题的实例"></a>线程池运用不当导致的问题的实例</h3><p><a href="https://github.com/whx123/JavaHome/blob/master/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%90%E7%94%A8%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98.md" target="_blank" rel="noopener">线程池运用不当导致的问题的实例</a></p>
<h2 id="redis-Redis-远程字典服务器-Remote-Dictionary-Server"><a href="#redis-Redis-远程字典服务器-Remote-Dictionary-Server" class="headerlink" title="redis - Redis 远程字典服务器 (Remote Dictionary Server)"></a>redis - Redis 远程字典服务器 (Remote Dictionary Server)</h2><h3 id="why-is-redis-so-fast"><a href="#why-is-redis-so-fast" class="headerlink" title="why is redis so fast"></a>why is redis so fast</h3><ol>
<li><p>Redis The data is in memory , All operations are memory level operations. Redis is a RAM-based data store. RAM access is at least 1000 times faster than random disk access.</p>
</li>
<li><p>Redis It’s single threaded, The loss caused by thread switching and locking is avoided. </p>
</li>
<li><p>Redis leverages IO multiplexing and single-threaded execution loop for execution efficiency,IO Multiplexer listens for multiple socket, And will socket Put in queue, One at a time from the queue socket To event dispatcher, The event dispatcher then socket Assign to the corresponding event processor for processing, These processors are pure memory operations, Very efficient, Processing an event may take only a few microseconds.</p>
</li>
<li><p>Redis data structure</p>
</li>
<li><p>Redis There is a file event handler inside, It is single threaded, It consists of four parts, namely ：IO Multiplex program,socket, Event dispatcher and event handler, The event processor is divided into：Connect reply processor, Command request processor and command reply processor.</p>
</li>
</ol>
<p>详情：<br><a href="https://www.iodraw.com/en/blog/220285360" target="_blank" rel="noopener">Redis Why fast</a><br><a href="https://www.iodraw.com/en/blog/220285360" target="_blank" rel="noopener">IO Multiplexing</a><br><a href="https://ylgrgyq.com/io-multiplexing.html" target="_blank" rel="noopener">IO 多路复用</a></p>
<p><img src="https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20221107174822.png" alt="20221107174822"></p>
<h3 id="redis-线程模型"><a href="#redis-线程模型" class="headerlink" title="redis 线程模型"></a>redis 线程模型</h3><p><a href="https://segmentfault.com/a/1190000039223696" target="_blank" rel="noopener">Redis 多线程网络模型全面揭秘</a></p>
<h3 id="redis缓存穿透，缓存击穿，缓存雪崩-布隆过滤器"><a href="#redis缓存穿透，缓存击穿，缓存雪崩-布隆过滤器" class="headerlink" title="redis缓存穿透，缓存击穿，缓存雪崩 布隆过滤器"></a>redis缓存穿透，缓存击穿，缓存雪崩 布隆过滤器</h3><p><a href="https://www.bilibili.com/video/BV1Yk4y1y76r?p=101&amp;spm_id_from=pageDriver" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Yk4y1y76r?p=101&amp;spm_id_from=pageDriver</a><br><a href="https://yaoyuanyy.github.io/2022/05/15/interview%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98%E8%8D%89%E5%BD%95/">https://yaoyuanyy.github.io/2022/05/15/interview%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98%E8%8D%89%E5%BD%95/</a> redis 缓存穿透，缓存击穿，缓存雪崩及解决方案</p>
<h3 id="redis-分布式锁"><a href="#redis-分布式锁" class="headerlink" title="redis 分布式锁"></a>redis 分布式锁</h3><p>锁的核心：互斥<br>redis 分布式锁的实现原理 setnx的弊端 redis分布式锁的过期时间设置方法</p>
<h4 id="1-上锁的问题"><a href="#1-上锁的问题" class="headerlink" title="1. 上锁的问题"></a>1. 上锁的问题</h4><p>setnx的弊端：设置锁和超时时间不是原子操作</p>
<blockquote>
<p>SETNX lock:168 1  // 获取锁<br>(integer) 1<br>EXPIRE lock:168 60  // 60s 自动删除</p>
</blockquote>
<p>方案：<br>2.6版本：SET resource_name random_value NX PX 30000</p>
<h4 id="2-解锁的问题"><a href="#2-解锁的问题" class="headerlink" title="2. 解锁的问题"></a>2. 解锁的问题</h4><ol>
<li>释放了不是自己加的锁</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">客户 1 获取锁成功并设置设置 30 秒超时；</span><br><span class="line">客户 1 因为一些原因导致执行很慢（网络问题、发生 FullGC……），过了 30 秒依然没执行完，但是锁过期「自动释放了」；</span><br><span class="line">客户 2 申请加锁成功；</span><br><span class="line">客户 1 执行完成，执行 DEL 释放锁指令，这个时候就把客户 2 的锁给释放了。</span><br></pre></td></tr></table></figure>
<p>方案：加锁时设置唯一标识(如随机数)，解锁时get 值与唯一标识判等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (redis.get(&quot;lock:168&quot;).equals(random_value))&#123;</span><br><span class="line">   redis.del(&quot;lock:168&quot;); //比对成功则删除</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li>依然有问题 - get del 不是原子操作</li>
</ol>
<p>方案：lua脚本</p>
<h4 id="3-超时时间的问题-锁的超时时间怎么计算合适呢？"><a href="#3-超时时间的问题-锁的超时时间怎么计算合适呢？" class="headerlink" title="3. 超时时间的问题 - 锁的超时时间怎么计算合适呢？"></a>3. 超时时间的问题 - 锁的超时时间怎么计算合适呢？</h4><p>设置短了，如发生网络io，fullgc，锁就失效了；设置成了，如果宕机，再回来，服务无法再获得锁</p>
<p>方案：redisson watchdog自动续期<br>我们可以让获得锁的线程开启一个守护线程，用来给快要过期的锁「续航」。<br>加锁的时候设置一个过期时间，同时客户端开启一个「守护线程」，定时去检测这个锁的失效时间。<br>如果快要过期，但是业务逻辑还没执行完成，自动对这个锁进行续期，重新设置过期时间。</p>
<h4 id="4-加解锁代码位置问题"><a href="#4-加解锁代码位置问题" class="headerlink" title="4. 加解锁代码位置问题"></a>4. 加解锁代码位置问题</h4><p>加解锁代码位置有讲究</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void doSomething() &#123;</span><br><span class="line">  redisLock.lock(); // 上锁</span><br><span class="line">    try &#123;</span><br><span class="line">        // (1)</span><br><span class="line">        .....</span><br><span class="line">        // (2)</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        redisLock.unlock(); // 释放锁</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加锁代码放（1）处的问题：lock方法里如果没有加锁成功服务异常了，解锁时会释放没有加锁的锁<br>释放锁这个问题比较明显了，不说了</p>
<h4 id="5-主从架构带来锁的问题"><a href="#5-主从架构带来锁的问题" class="headerlink" title="5. 主从架构带来锁的问题"></a>5. 主从架构带来锁的问题</h4><p>具体的问题场景：主从下master宕机，slave还没有master上的key，造成重复获取锁。<br>本质是redis集群数据同步机制<br>由于 Redis 集群数据同步到各个节点时是异步的，如果在 Redis 主节点获取到锁后，在没有同步到其他节点时，Redis 主节点宕机了，此时新的 Redis 主节点依然可以获取锁，所以多个应用服务就可以同时获取到锁。</p>
<p>以上详情阅读：<a href="https://segmentfault.com/a/1190000041172633" target="_blank" rel="noopener">Redis 分布式锁的正确实现原理演化历程与 Redission 实战总结</a></p>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E7%B2%BE%E8%AE%B2/06%20%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E5%9B%9E%E7%AD%94%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F.md" target="_blank" rel="noopener">https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E7%B2%BE%E8%AE%B2/06%20%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E5%9B%9E%E7%AD%94%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F.md</a></p>
<h3 id="redis-key的过期策略"><a href="#redis-key的过期策略" class="headerlink" title="redis key的过期策略"></a>redis key的过期策略</h3><p>关键词：<br>集中删除(定时删除) + 惰性删除(访问key时删除)<br>集中删除：redis 会将每个设置了过期时间的 key 放入到一个独立的字典中，有个定时器，会定时遍历这个字典来删除到期的 key。<br>惰性删除：在客户端访问这个 key 的时候，redis 对 key 的过期时间进行检查，如果过期了就立即删除。<br>定时删除是集中处理，惰性删除是零散处理。</p>
<p><a href="https://juejin.cn/book/6844733724618129422/section/6844733724731375623" target="_blank" rel="noopener">Redis 深度历险：核心原理与应用实践-过期策略章节</a> </p>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Redis%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/18%20Redis%20%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md" target="_blank" rel="noopener">Redis 过期策略与源码分析.md</a></p>
<h3 id="redis-内存淘汰策略-Key-eviction-it-s-policies-is-LRU-LFU-etc"><a href="#redis-内存淘汰策略-Key-eviction-it-s-policies-is-LRU-LFU-etc" class="headerlink" title="redis 内存淘汰策略 Key eviction (it`s policies is LRU, LFU, etc.)"></a>redis 内存淘汰策略 Key eviction (it`s policies is LRU, LFU, etc.)</h3><p>关键词：<br>为啥淘汰：超过maxmemory<br>何时淘汰：add key/value时，redis检查如果发现超过maxmemory<br>咋样淘汰：根据淘汰策略 evicts keys，类似 LRU，LFU</p>
<p><a href="https://www.modb.pro/db/41628" target="_blank" rel="noopener">玩转Redis：8种数据淘汰策略及近似LRU、LFU原理</a></p>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Redis%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/23%20%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%E4%B8%8E%E7%AE%97%E6%B3%95.md" target="_blank" rel="noopener">23 内存淘汰机制与算法.md</a></p>
<h4 id="LRU算法-突出访问的先后-顺序"><a href="#LRU算法-突出访问的先后-顺序" class="headerlink" title="LRU算法 - 突出访问的先后(顺序)"></a>LRU算法 - 突出访问的先后(顺序)</h4><p>LRU（Least Recently Used）最近最少使用(最近最久未使用)。优先淘汰最近未被使用的数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。</p>
<p>LRU底层结构是 hash 表 + 双向链表。hash 表用于保证查询操作的时间复杂度是O(1)，双向链表用于保证节点插入、节点删除的时间复杂度是O(1)。</p>
<p>为什么是 双向链表而不是单链表呢？单链表可以实现头部插入新节点、尾部删除旧节点的时间复杂度都是O(1)，但是对于中间节点时间复杂度是O(n)，因为对于中间节点c，我们需要将该节点c移动到头部，此时只知道他的下一个节点，要知道其上一个节点需要遍历整个链表，时间复杂度为O(n)。</p>
<p>注意：redis使用的是近似LRU，为啥呢?</p>
<p>LRU算法源码可参考Leetcode：<a href="https://www.programcreek.com/2013/03/leetcode-lru-cache-java/" target="_blank" rel="noopener">https://www.programcreek.com/2013/03/leetcode-lru-cache-java/</a></p>
<p><a href="https://www.modb.pro/db/41628" target="_blank" rel="noopener">玩转Redis：8种数据淘汰策略及近似LRU、LFU原理 - LRU部分</a></p>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Redis%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/23%20%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%E4%B8%8E%E7%AE%97%E6%B3%95.md" target="_blank" rel="noopener">redis核心原理与实战  - 内存淘汰机制与算法.md</a></p>
<h4 id="LFU算法-突出访问的次数-频率"><a href="#LFU算法-突出访问的次数-频率" class="headerlink" title="LFU算法 - 突出访问的次数(频率)"></a>LFU算法 - 突出访问的次数(频率)</h4><p>LFU：Least Frequently Used，最近使用频率最少的（最不频繁使用的）</p>
<p>LFU 使用 Morris counter 概率计数器，仅使用几比特就可以维护 访问频率，Morris算法利用随机算法来增加计数，在 Morris 算法中，计数不是真实的计数，它代表的是实际计数的量级。</p>
<p>优先淘汰最近使用的少的数据，其核心思想是“如果一个数据在最近一段时间很少被访问到，那么将来被访问的可能性也很小</p>
<p><a href="https://www.modb.pro/db/41628" target="_blank" rel="noopener">玩转Redis：8种数据淘汰策略及近似LRU、LFU原理 - LFU部分</a></p>
<h3 id="redis-bigKey问题"><a href="#redis-bigKey问题" class="headerlink" title="redis bigKey问题"></a>redis bigKey问题</h3><ol>
<li><p>What bigKey 是什么</p>
</li>
<li><p>有什么影响(危害)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.内存空间的影响：redis集群一般是单机多实例部署，所以会导致内存空间不均衡，影响整个集群。</span><br><span class="line">2.请求阻塞的影响：redis操作大key非常耗时，属于慢查询，执行时间过长时，会阻塞其他客户端。因为 Redis 单线程特性，如果操作某个 Bigkey 耗时比较久，则后面的请求会被阻塞。</span><br><span class="line">3.网卡流量的影响：当大key例如12MB时，如果这个key每秒访问量是100的话，每秒产生流量为1200MB，对于普通服务器一般是扛不住这么大的流量的。</span><br><span class="line">4.bigkey過期刪除時造成命令阻塞 Redis 4.0通过异步命令解决</span><br><span class="line">5.数据倾斜：一个实例数据特别多，其他的相对少</span><br></pre></td></tr></table></figure>
</li>
<li><p>Why 产生的原因是什么<br>一般來說，bigkey的產生都是由於程序設計不當。沒有對Key中的成員進行合理的拆分，造成個別Key中的成員數量過多(大Key)。</p>
</li>
<li><p>如何发现 bigKey<br>工具</p>
</li>
<li><p>How 解决的办法是什么</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.拆分大key。</span><br><span class="line">如果对象是整存争取，将对象拆分后才能多个小key-value,get不同的key或者批量获取stringRedisTemplate.opsForValue() .multiGet(keyList)</span><br><span class="line"></span><br><span class="line">如果对象是部分更新获取数据，可以分拆成几个key-value,也可以存储在hash中,部分更新部分存取!</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 针对数据清晰</span><br><span class="line">对 big key 存储的数据 （big value）进行拆分，变成value1，value2… valueN,如果big value 是个大json 通过 mset 的方式，将这个 key 的内容打散到各个实例中，减小big key 对数据量倾斜造成的影响。</span><br><span class="line">//存</span><br><span class="line">mset key1, vlaue1, key2, vlaue2 ... keyN, valueN</span><br><span class="line">//取</span><br><span class="line">mget key1, key2 ... keyN</span><br><span class="line">复制代码如果big value 是个大list，可以拆成将list拆成。= list_1， list_2, list3, listN</span><br><span class="line"></span><br><span class="line">2.增加本地缓存</span><br><span class="line">3.對大Key進行清理，定期刪除並設定TTL。</span><br><span class="line">4.进行接口重构,重新设计接口。</span><br></pre></td></tr></table></figure>
<p><a href="https://molin.cool/2020/06/10/%E8%AE%B0%E4%B8%80%E6%AC%A1Redis-Big-Key%E4%BC%98%E5%8C%96/" target="_blank" rel="noopener">记一次Redis Big Key优化经历</a></p>
<p><a href="https://medium.com/jerrynotes/redis-bigkey-or-hotkey-issue-7bbe20d2ea2c" target="_blank" rel="noopener">Redis Bigkey or Hotkey issue?</a></p>
<h3 id="redis-hotKey问题"><a href="#redis-hotKey问题" class="headerlink" title="redis hotKey问题"></a>redis hotKey问题</h3><ol>
<li><p>What hotKey 是什么</p>
</li>
<li><p>有什么影响(危害)</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 流量集中，达到服务器处理上限（CPU、网络 IO 等）；</span><br><span class="line">2. 会影响在同一个 Redis 实例上其他 Key 的读写请求操作；</span><br><span class="line">3. 热 Key 请求落到同一个 Redis 实例上，无法通过扩容解决；</span><br><span class="line">4. 大量 Redis 请求失败，查询操作可能打到数据库，拖垮数据库，导致整个服务不可用。</span><br><span class="line">5. 操作延遲。由於Redis單線程的特性，操作会影响在同一个 Redis 实例上其他 Key 的读写请求操作；</span><br><span class="line">6. 操作延遲。大量 Redis 请求失败，查询操作可能打到数据库，拖垮数据库，导致整个服务不可用。</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>Why 产生的原因是什么</li>
</ol>
<p>预期外的访问量陡增，如突然出现的爆款商品、访问量暴涨的热点新闻、主播搞活动带来的大量刷屏点赞等</p>
<ol start="4">
<li><p>如何发现 hotKey</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">客户端收集上报</span><br><span class="line">代理层收集上报</span><br><span class="line">Redis 数据定时扫描hotkeys 查找特性，可以直接利用 redis-cli --hotkeys 获取当前 keyspace 的热点 key，实现上是通过 scan + object freq 完成的</span><br><span class="line">Redis 节点抓包解析</span><br></pre></td></tr></table></figure>
</li>
<li><p>How 解决的办法是什么</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">增加 Redis 实例复本数量: 分担读流量</span><br><span class="line">热 Key 备份: 比如key，备份为key1,key2……keyN，同样的数据N个备份，N个备份分布到不同分片，访问时可随机访问N个备份中的一个,进一步分担读流量</span><br><span class="line">二级缓存（本地缓存）: 使用本地缓存，发现热key后，将热key对应数据加载到应用服务器本地缓存中，访问热key数据时，直接从本地缓存中获取，而不会请求到redis服务器。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><a href="https://dongzl.github.io/2021/01/14/03-Redis-Hot-Key/index.html" target="_blank" rel="noopener">Redis 热 Key 发现以及解决办法</a><br><a href="https://www.cnblogs.com/rjzheng/p/10874537.html" target="_blank" rel="noopener">谈谈redis的热key问题如何解决 </a><br><a href="https://medium.com/jerrynotes/redis-bigkey-or-hotkey-issue-7bbe20d2ea2c" target="_blank" rel="noopener">Redis Bigkey or Hotkey issue?</a></p>
<h3 id="redis-zset底层实现原理"><a href="#redis-zset底层实现原理" class="headerlink" title="redis zset底层实现原理"></a>redis zset底层实现原理</h3><p>skiplist 跳跃表</p>
<h3 id="Redis实现高可用-怎么防止数据丢失"><a href="#Redis实现高可用-怎么防止数据丢失" class="headerlink" title="Redis实现高可用(怎么防止数据丢失)"></a>Redis实现高可用(怎么防止数据丢失)</h3><p>在 Web 服务器中，高可用 是指服务器可以 正常访问 的时间，衡量的标准是在 多长时间 内可以提供正常服务（99.9%、99.99%、99.999% 等等）。在 Redis 层面，高可用 的含义要宽泛一些，除了保证提供 正常服务（如 主从分离、快速容灾技术 等），还需要考虑 数据容量扩展、数据安全 等等。</p>
<p>主要有以下方面来保证：<br>1.持久化：<br>持久化是 最简单的 高可用方法。它的主要作用是 数据备份，即将数据存储在 硬盘，保证数据不会因进程退出而丢失。</p>
<p>2.复制：<br>复制是高可用 Redis 的基础，哨兵 和 集群 都是在 复制基础 上实现高可用的。复制主要实现了数据的多机备份以及对于读操作的负载均衡和简单的故障恢复。缺陷是故障恢复无法自动化、写操作无法负载均衡、存储能力受到单机的限制。</p>
<p>3.哨兵：<br>在复制的基础上，哨兵实现了 自动化 的 故障恢复。缺陷是 <em>写操作</em> 无法负载均衡，存储能力受到单机的限制。</p>
<p>4.集群：<br>通过集群，提高了 <em>写操作</em> 能力，Redis 解决了 <em>写操作</em> 无法负载均衡以及存储能力受到单机限制的问题，实现了较为完善的高可用方案。</p>
<p>5.自动故障恢复</p>
<ol>
<li>-&gt; 数据持久化 - 高可用的基础</li>
</ol>
<p>因为Redis的主从复制和自动故障恢复，都需要依赖Redis持久化相关的东西。同时，Redis的数据持久化也可以用来做数据备份，保障数据的安全性。<br>Redis提供了完善的持久化机制，可以把内存中的数据持久化到磁盘上，以便我们进行备份数据和快速恢复数据。</p>
<p>Redis提供的数据持久化方式主要有2种：<br>RDB(Redis Database Backup file)：产生一个数据快照文件。RDB文件数据是被压缩写入的，因此RDB文件的体积要比整个实例内存要小。实例宕机恢复时，可以很短时间内迅速恢复。但缺点是：由于是某一时刻的数据快照，因此它的数据并不全<br>AOF(append of file)：实时追加命令的日志文件。比RDB保存更完整的数据，降低丢失数据的风险。但缺点是：随着时间增长，AOF文件会越来越大。同时，AOF文件刷盘会增加磁盘IO的负担，可能影响Redis的性能（开启每秒刷盘时）</p>
<p>参考：<a href="https://cloud.tencent.com/developer/article/1730906" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1730906</a></p>
<ol start="2">
<li>-&gt; 主从复制</li>
</ol>
<p>Redis 的主从复制模式下，一旦主节点由于故障不能提供服务，需要手动将从节点晋升为主节点，同时还要通知客户端更新主节点地址，这种故障处理方式从一定程度上是无法接受的。Redis 2.8 以后提供了 Redis Sentinel 哨兵机制解决这个问题。</p>
<p>主从还有一个好处：读写分离</p>
<ol start="3">
<li>-&gt; 哨兵模式</li>
</ol>
<p>Redis Sentinel 是 Redis 高可用的实现方案。Sentinel 是一个管理多个 Redis 实例的工具，它可以实现对 Redis 的监控、通知、自动故障转移。</p>
<p>Redis 的 主从复制模式 和 Sentinel 高可用架构 的示意图</p>
<p><img src="https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20221110174626.png" alt="20221110174626"></p>
<p><a href="https://juejin.cn/post/6844903663362637832" target="_blank" rel="noopener">https://juejin.cn/post/6844903663362637832</a><br><a href="https://cloud.tencent.com/developer/article/1707625" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1707625</a></p>
<ol start="4">
<li>-&gt; 集群 redis cluster的原理<br>Redis主从复制利用主从节点实现读写分离来扩展主节点的数据读取能力，那么当主节点的写入能力成为瓶颈时，集群便是性能扩展的解决方案之一。Redis Cluster是Redis的分布式解决方案</li>
</ol>
<p><img src="https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20221112181145.png" alt="20221112181145"></p>
<p>4.1 数据分布策略 - CRC16/16384<br>Redis采用了虚拟桶分区方法，使用分散度良好地哈希函数把所有的数据均匀地哈希到K个桶中。具体实现中，Redis使用CRC16函数计算键的哈希值并把所有键分到16384个桶中。每个桶只能由一个主节点存储，但一个主节点可以负责多个桶。</p>
<p>4.2 数据查询路由 - MOVED重定向</p>
<p><strong>Redis没有选择使用代理，而是客户端直接连接每个节点。</strong> Redis的每个节点中都存储着整个集群的状态，集群状态中一个重要的信息就是每个桶的负责节点。在具体的实现中，Redis用一个大小固定为CLUSTER_SLOTS的clusterNode数组 slots来保存每个桶的负责节点。</p>
<p>在集群模式下，Redis接收任何键相关命令时首先计算键对应的桶编号，再根据桶找出所对应的节点，如果节点是自身，则处理键命令；否则回复MOVED重定向错误，通知客户端请求正确的节点，这个过程称为MOVED重定向。重定向信息包含了键所对应的桶以及负责该桶的节点地址，根据这些信息客户端就可以向正确的节点发起请求。</p>
<p>4.3 集群节点通信 - Gossip协议<br>集群中所有节点的状态以及桶-节点映射关系构成集群的元数据。 <strong>Redis采用Gossip通信协议来进行集群元数据的同步。</strong> Gossip协议的主要职责就是信息交换。信息交换的载体就是节点彼此发送的Gossip消息。每个Redis都会保存自己视角下的集群中其他节点的状态信息，具体实现中所有的节点信息都存储在clusterNode结构体中。那么使用Gossip协议，集群中的每个节点，每次会随机向几个节点传输自己视角下的集群其他节点状态。如果每次都传输所有的节点状态数据，那么数据体量又会过于庞大，于是Redis集群采用的最终的信息同步方式是： 一个大小为N的集群的每一个节点每次向随机K个其他节点传输自己视角下的随机M个节点的状态。其中M和K都远远小于N。</p>
<p><a href="https://zhuanlan.zhihu.com/p/104641341" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/104641341</a></p>
<p>4.4 集群伸缩</p>
<p>集群伸缩的核心其实是数据的迁移，而在Redis集群中，数据是以slot为单位的，那么也就是说，<strong>Redis集群的伸缩本质上是slot在不同机器节点间的迁移。</strong> 同时，要实现扩缩容，<strong>我们不仅需要解决数据迁移，我们还需要解决数据路由问题。</strong> 比如A节点正在向B节点迁移slot1的数据，在未完成迁移时，slot1中的一部分数据存在节点A上，一部分数据存在节点B上。那么以下三种情况下我们该如何路由slot1的客户端请求？</p>
<ul>
<li>当除了A、B之外的其他节点接收到slot1的数据请求时，其他节点该路由给哪个节点？</li>
<li>当节点A接收到slot1的数据请求时，A该自己处理还是路由给B节点？</li>
<li>当节点B接收到slot1的数据请求时，B该自己处理还是路由给A节点？</li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/105569485" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/105569485</a></p>
<p><a href="http://www.redis.cn/topics/cluster-spec.html" target="_blank" rel="noopener">Redis 集群规范 - 中文</a></p>
<p><a href="https://redis.io/docs/reference/cluster-spec/" target="_blank" rel="noopener">Redis 集群规范 - 英文</a></p>
<ol start="5">
<li>-&gt; 自动故障恢复总体介绍</li>
</ol>
<p>我们在之前提到过，Redis将所有的数据都分到了16384个slots里面同时每个节点负责一部分slots。slot和节点的对应关系是多对一的关系，即每个slot只能被至多一个节点负责存储，每个节点可以负责存储多个slots。所谓的高可用指的是，即使其中一个Master节点下线，整个集群依然能够正常向外提供服务。这是如何做到的呢？<code>简单的来说就是让下线Master节点的Slave节点来成为新的Master节点，接管旧Master负责的所有slots向外提供服务。</code>比如下面的集群拓扑结构，每个Master节点带一个Slave节点。如果M2永久下线之后，那么S2就会替代M2继续向外服务。那么如果替代的S2再次下线后会怎么样呢？显然由于S2不再有Slave节点了，所以S2下线之后整个集群就下线了。为了解决这个问题，Redis还提出一个叫 Replica Migration的解决方案：当集群中的某个Master节点没有Slave节点时（称之为 Orphaned Master），其他有富余Slave节点的主节点会向该节点迁移一个Slave节点以防该节点下线之后没有子节点来替换从而导致整个集群下线。</p>
<p>Redis cluster — 故障自动检测与自动恢复</p>
<ul>
<li>1.故障发现：<br>如何判定某个Master节点故障了？<strong>Redis采用了多数投票的方案。</strong></li>
</ul>
<p>Redis的每个节点会不停的向其他节点发送PING消息来与其他节点同步信息的同时检测其他节点是否可达。</p>
<p>Redis集群的故障发现也经历两个阶段：PFail和Fail。PFAIL就是主观下线，比如节点1判定节点3下线，那么他会标记节点3的状态为PFAIL。但是如果绝大部分节点都判定节点3为PFAIL，那么我们就可以断定节点3故障下线，其状态判定为FAIL状态。</p>
<p>1).PFAIL：当定超过NODE_TIMEOUT，认为这个节点是PFAIL<br>2).FAIL：超过一半的节点报告某一节点是PFAIL，那么就判定这个节点FAIL。<br>3)客观下线状态判定:下线报告列表中超过一半的节点报告某一节点是PFAIL，那么就判定这个节点FAIL。<br>4).广播信息：判定节点通过 Gossip 广播某一节点的故障消息。当集群中的节点收到此消息时，都会标记节点3的状态为FAIL状态.</p>
<ul>
<li><ol start="2">
<li>故障迁移</li>
</ol>
</li>
</ul>
<p>Redis子节点竞选成为新的Master节点采用了Raft协议</p>
<p>1).资格检查：当一个Slave节点过长时间不与Master节点通信，那么该节点就不具备参与竞选的资格。详情有代码公式<br>2).休眠时间计算：DELAY = 500 milliseconds + random delay between 0 and 500 milliseconds + SLAVE_RANK * 1000 milliseconds.<br>3).发起拉票&amp;选举投票：有资格的候选节点向所有的节点（主节点+子节点）都会收到拉票请求，但是只有主节点才具备投票资格<br>4).节点替换：先标记自己为主节点，然后将原来节点负责的slots标记为由自己负责，最后向整个集群广播现在自己是Master同时负责旧Master所有slots的信息。其他节点接收到该信息后会更新自己维护的这个节点的状态<br>5).集群配置更新：</p>
<p><a href="https://zhuanlan.zhihu.com/p/106110578" target="_blank" rel="noopener">Redis集群 — 故障自动检测与自动恢复</a></p>
<ol start="6">
<li>-&gt; Redis 主从复制、哨兵和集群这三个有什么区别 </li>
</ol>
<p>主从复制是为了数据备份和负载均衡，哨兵是为了高可用，Redis主服务器挂了哨兵可以切换，集群则是解决单实例能力有限的问题，将数据按一定的规则分配到多台机器，sentinel着眼于高可用，Cluster提高并发量。<br>1).主从模式：读写分离，备份，一个Master可以有多个Slaves。<br>2).哨兵sentinel：监控，自动转移，哨兵发现主服务器挂了后，就会从slave中重新选举一个主服务器。<br>3).集群：为了解决单机Redis容量有限的问题，将数据按一定的规则分配到多台机器，内存/QPS不受限于单机，可受益于分布式集群高扩展性。</p>
<h3 id="redis在高并发-高性能的应用"><a href="#redis在高并发-高性能的应用" class="headerlink" title="redis在高并发 高性能的应用"></a>redis在高并发 高性能的应用</h3><ol>
<li>收藏点赞<br><a href="https://www.bbsmax.com/A/RnJWZoZyzq/" target="_blank" rel="noopener">https://www.bbsmax.com/A/RnJWZoZyzq/</a></li>
</ol>
<p>新浪微博开放平台Redis实战</p>
<h3 id="高频面试题"><a href="#高频面试题" class="headerlink" title="高频面试题"></a>高频面试题</h3><h4 id="redis如何实现延时队列"><a href="#redis如何实现延时队列" class="headerlink" title="redis如何实现延时队列"></a>redis如何实现延时队列</h4><p>Redis 是通过有序集合（ZSet）的方式来实现延迟消息队列的，ZSet 有一个 Score 属性可以用来存储延迟执行的时间。</p>
<p>优点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">灵活方便，Redis 是互联网公司的标配，无序额外搭建相关环境；</span><br><span class="line">可进行消息持久化，大大提高了延迟队列的可靠性；</span><br><span class="line">分布式支持，不像 JDK 自身的 DelayQueue；</span><br><span class="line">高可用性，利用 Redis 本身高可用方案，增加了系统健壮性。</span><br></pre></td></tr></table></figure></p>
<p>缺点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需要使用无限循环的方式来执行任务检查，会消耗少量的系统资源。</span><br></pre></td></tr></table></figure></p>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/Redis%20%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98/30%20%E5%AE%8C%E6%95%B4%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95.md" target="_blank" rel="noopener">代码实现</a></p>
<h4 id="redis集群下一组一个master和两个slave挂了，-redis还能提供服务吗"><a href="#redis集群下一组一个master和两个slave挂了，-redis还能提供服务吗" class="headerlink" title="redis集群下一组一个master和两个slave挂了， redis还能提供服务吗"></a>redis集群下一组一个master和两个slave挂了， redis还能提供服务吗</h4><p>Redis Cluster failure detection is used to recognize when a master or slave node is no longer reachable by the majority of nodes and then respond by promoting a slave to the role of master. <strong>When slave promotion is not possible the cluster is put in an error state to stop receiving queries from clients.</strong></p>
<p>Replica migration (复制迁移算)<br>    Redis Cluster实现了一个成为“Replica migration”的概念，用来提升集群的可用性。比如集群中每个master都有一个slave，当集群中有一个master或者slave失效时，而不是master与它的slave同时失效，集群仍然可以继续提供服务。</p>
<pre><code>1）master A，有一个slave A1
2）master A失效，A1被提升为master
3）一段时间后，A1也失效了，那么此时集群中没有其他的slave可以接管服务，集群将不能继续服务。

如果masters与slaves之间的映射关系是固定的（fixed），提高集群抗灾能力的唯一方式，就是给每个master增加更多的slaves，不过这种方式开支很大，需要更多的redis实例。

解决这个问题的方案，我们可以将集群非对称，且在运行时可以动态调整master-slaves的布局（而不是固定master-slaves的映射），比如集群中有三个master A、B、C，它们对应的slave为A1、B1、C1、C2，即C节点有2个slaves。“Replica迁移”可以自动的重新配置slave，将其迁移到某个没有slave的master下。

1）A失效，A1被提升为master
2）此时A1没有任何slave，但是C仍然有2个slave，此时C2被迁移到A1下，成为A1的slave
3）此后某刻，A1失效，那么C2将被提升为master。集群可以继续提供服务。
</code></pre><p>Replica migration algorithm (复制迁移算法)<br>    迁移算法并没有使用“agree”形式，而是使用一种算法来避免大规模迁移，这个算法确保最终每个master至少有一个slave即可。起初，我们先定义哪个slave是良好的：一个良好的slave不能处于FAIL状态。触发时机为，任何一个slave检测到某个master没有一个良好slave时。参与迁移的slave必须为，持有最多slaves的master的其中一个slave，且不处于FAIL状态，且持有最小的node ID。</p>
<pre><code>比如有10个masters都持有一个slave，有2个masters各持有5个slaves，那么迁移将会发生在持有5个slaves的masters中，且node ID最小的slave node上。我们不再使用“agreement”，不过也有可能当集群的配置不够稳定时，有一种竞争情况的发生，即多个slaves都认为它们自己的ID最小；如果这种情况发生，结果就是可能多个slaves会迁移到同一个master下，不过这并没有什么害处，但是最坏的结果是导致原来的master迁出了所有的slaves，让自己变得单一。但是迁移算法（进程）会在迁移完毕之后重新判断，如果尚未平衡，那么将会重新迁移。

最终，每个master最少持有一个slave；这个算法由用户配置的“cluster-migration-barrier”，此配置参数表示一个master至少保留多少个slaves，其他多余的slaves可以被迁出。此值通常为1，如果设置为2，表示一个master持有的slaves个数大于2时，多余的slaves才可以迁移到持有更少slaves的master下。
</code></pre><p><a href="https://redis.io/docs/reference/cluster-spec/#replica-migration-algorithm" target="_blank" rel="noopener">复制迁移算法</a><br><a href="https://www.cnblogs.com/kaleidoscope/p/9635163.html" target="_blank" rel="noopener">Redis Cluster实现原理 - 复制迁移</a></p>
<h4 id="redis-cluster的原理"><a href="#redis-cluster的原理" class="headerlink" title="redis cluster的原理"></a>redis cluster的原理</h4><p>见上文</p>
<h4 id="redis-hotkey如何解决，超高的qps-写操作"><a href="#redis-hotkey如何解决，超高的qps-写操作" class="headerlink" title="redis hotkey如何解决，超高的qps 写操作"></a>redis hotkey如何解决，超高的qps 写操作</h4><ol>
<li><p>hotkey如何解决<br>参考上文</p>
</li>
<li><p>超高的qps 写操作<br>使用pipeline，相当于组成批量请求，然后再发送到redis服务器</p>
</li>
</ol>
<h4 id="redis-高并发写操作"><a href="#redis-高并发写操作" class="headerlink" title="redis 高并发写操作"></a>redis 高并发写操作</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>先说下为什么redis会存在并发问题，redis不是单线程吗，不管你多少个请求过来，我就只有一个线程，它怎么会有线程安全问题呢？讲道理永远不会出现并发问题； </p>
<p>我们正常理解的线程安全问题是指单进程多线程模型内部多个线程操作进程内共享内存导致的数据资源充突。而 Redis 的线程安全问题的产生，并不是来自于 Redis 服务器内部。</p>
<p>问题的产生并不是来自于 Redis 服务器内部。</p>
<p>这里的并发问题指的是，多个客户端同时对一个key进行写操作(如库存增减)。多个客户端就相当于同一进程下的多个线程，如果多个客户端之间没有良好的数据同步策略，就会产生类似线程安全的问题。</p>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><ol>
<li>加时间戳：操作a变量时候，额外维护一个时间戳</li>
<li>基于消息队列：把所有操作写入同一个队列，利用消息队列把所有操作串行化</li>
<li>利用原子性：使用本身就具有原子性的redis 函数：incryby</li>
<li>利用原子性：使用 Lua 脚本：将多个操作形成一个原子操作</li>
<li>Redis事务：通过watch+mutil解决并发修改的问题</li>
</ol>
<p><a href="https://bbs.huaweicloud.com/blogs/332041" target="_blank" rel="noopener">如何解决redis并发竞争key</a><br><a href="https://z.itpub.net/article/detail/5B60093E42AE162BEF331F0F77D0628D" target="_blank" rel="noopener">Redis 是并发安全的吗？你确定？</a><br><a href="https://time.geekbang.org/column/article/299806" target="_blank" rel="noopener">答案最全 - Redis 核心技术与实战 - 29 | 无锁的原子操作：Redis如何应对并发访问？</a><br><a href="https://www.freebuf.com/articles/system/340776.html" target="_blank" rel="noopener">实际场景方案 - 电商库存系统的防超卖和高并发扣减方案</a><br><a href="https://www.cnblogs.com/yy3b2007com/p/9383713.html" target="_blank" rel="noopener">实际举例 - 事务应用 - Redis：解决分布式高并发修改同一个Key的问题 </a><br><a href="https://www.cnblogs.com/shamo89/p/8376907.html" target="_blank" rel="noopener">Redis(十一):Redis的事务功能详解</a></p>
<h4 id="redis-zset-底层的数据结构是什么"><a href="#redis-zset-底层的数据结构是什么" class="headerlink" title="redis zset 底层的数据结构是什么"></a>redis zset 底层的数据结构是什么</h4><p>跳跃表</p>
<p>跳跃表和堆排序的区别是什么</p>
<h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><ol>
<li>LRU </li>
<li>LFU </li>
<li>SkipList</li>
</ol>
<h4 id="高并发下redis和数据库的强一致如何保证-redis与mysql数据一致性"><a href="#高并发下redis和数据库的强一致如何保证-redis与mysql数据一致性" class="headerlink" title="高并发下redis和数据库的强一致如何保证(redis与mysql数据一致性)"></a>高并发下redis和数据库的强一致如何保证(redis与mysql数据一致性)</h4><p>主要考虑两个问题：<br>1、执行顺序的问题：先更新缓存还是先更新数据库？<br>2、更新缓存的策略问题：当缓存中的内容变化时，是选择修改缓存(update)，还是直接淘汰缓存(delete)？</p>
<p>总体：删除缓存好过更新缓存；</p>
<p>针对这两点问题，一共可以分为四种方案：<br>  1、先更新缓存，再更新数据库；// 数据丢失风险(挂机) - 直接不考虑<br>  2、先更新数据库，再更新缓存；// 1. 数据上：脏数据(A库B库B缓A缓导致)；2. 业务上：写入场景多，缓存频繁更新；写入db后，需要再计算后写入缓存，浪费性能<br>  3、先删除缓存，再更新数据库；<br>  4、先更新数据库，再删除缓存。</p>
<p><strong>一条口诀验证以上四种方式是否会有问题：两个线程并发，写一半，查进来；查一半，写进来</strong></p>
<ol>
<li><p>先删除缓存，再更新数据库 - 请求A更新，请求B查询，B的操作夹在了A删缓和写库之间，造成<strong>缓存脏数据</strong><br>该方案会导致不一致的原因是。同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:<br>（1）请求A进行写操作，删除缓存<br>（2）请求B查询发现缓存不存在<br>（3）请求B去数据库查询得到旧值<br>（4）请求B将旧值写入缓存<br>（5）请求A将新值写入数据库<br>上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。<br>那么，<strong>如何解决呢？采用延时双删策略</strong>，即（1）先淘汰缓存（2）再写数据库（这两步和原来一样）（3）休眠1秒，再次淘汰缓存（最好异步）。进一步提出问题：<strong>第（3）步失败咋办呢？答：写入MQ，(异步)自消费重试</strong></p>
</li>
<li><p>先更新数据库，再删缓存<br>不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生<br>（1）缓存刚好失效<br>（2）请求A查询数据库，得一个旧值<br>（3）请求B将新值写入数据库<br>（4）请求B删除缓存<br>（5）请求A将查到的旧值写入缓存<br>ok，如果发生上述情况，确实是会发生脏数据。<br>然而，发生这种情况的概率又有多少呢？<br>发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。假设，有人非要抬杠，有强迫症，一定要解决怎么办？<strong>采用延时双删策略</strong></p>
</li>
</ol>
<p>还有一个问题：删缓存失败了？答：写入MQ，自消费</p>
<p><strong>所以，归纳下，相对而言，采用先更新数据库，再删缓存。无论是先更新库再删缓存，还是先删缓存，再更新库，并发的问题总体可采用延时双删，如果删除失败，放MQ，(异步)自消费重试</strong></p>
<p><a href="https://www.cnblogs.com/rjzheng/p/9041659.html" target="_blank" rel="noopener">独孤烟 - 分布式之数据库和缓存双写一致性方案解析</a><br><a href="https://www.cnblogs.com/rjzheng/p/9240611.html" target="_blank" rel="noopener">独孤烟 - 分布式之数据库和缓存双写一致性方案解析二</a><br><a href="https://www.cnblogs.com/rjzheng/p/9302609.html" target="_blank" rel="noopener">独孤烟 - 分布式之数据库和缓存双写一致性方案解析三</a></p>
<p><a href="https://mp.weixin.qq.com/s?spm=a2c6h.12873639.article-detail.9.2020fe8d9N0cP9&amp;__biz=MjM5ODYxMDA5OQ==&amp;mid=404202261&amp;idx=1&amp;sn=1b8254ba5013952923bdc21e0579108e&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">缓存与数据库一致性保证</a></p>
<p><a href="https://mp.weixin.qq.com/s?spm=a2c6h.12873639.article-detail.10.2020fe8d9N0cP9&amp;__biz=MjM5ODYxMDA5OQ==&amp;mid=404308725&amp;idx=1&amp;sn=1a25ce76dd1956014ceb8a011855268e&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">架构师之路 - 主从DB与cache一致性</a></p>
<h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><h3 id="Innodb"><a href="#Innodb" class="headerlink" title="Innodb"></a>Innodb</h3><h4 id="索引数据结构-B-tree"><a href="#索引数据结构-B-tree" class="headerlink" title="索引数据结构 B+tree"></a>索引数据结构 B+tree</h4><h4 id="Mysql-索引的底层实现原理"><a href="#Mysql-索引的底层实现原理" class="headerlink" title="Mysql 索引的底层实现原理"></a>Mysql 索引的底层实现原理</h4><h4 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h4><p>Buffer Pool 有三个链表  free链表，flush链表，LRU链表</p>
<h5 id="Buffer-Pool中的LRU淘汰算法"><a href="#Buffer-Pool中的LRU淘汰算法" class="headerlink" title="Buffer Pool中的LRU淘汰算法"></a>Buffer Pool中的LRU淘汰算法</h5><p><a href="https://www.jianshu.com/p/7cb6d7d59064" target="_blank" rel="noopener">https://www.jianshu.com/p/7cb6d7d59064</a></p>
<h4 id="change-buffer详解"><a href="#change-buffer详解" class="headerlink" title="change buffer详解"></a>change buffer详解</h4><p>The change buffer is a special data structure that caches changes to secondary index pages when those pages are not in the buffer pool. The buffered changes, which may result from INSERT, UPDATE, or DELETE operations (DML), are merged later when the pages are loaded into the buffer pool by other read operations.</p>
<p>Change buffer的主要目的是将对二级索引的数据操作缓存下来，以此减少二级索引的随机IO，并达到操作合并的效果。</p>
<p>InnoDB change buffer可以对三种类型的操作进行缓存：INSERT、DELETE-MARK 、DELETE操作，前两种对应用户线程操作，第三种则由purge操作触发。</p>
<h4 id="mysql-写多读少场景，更新一条语句时，条件中唯一索引和普通索引哪个选择更好的，为什么"><a href="#mysql-写多读少场景，更新一条语句时，条件中唯一索引和普通索引哪个选择更好的，为什么" class="headerlink" title="mysql 写多读少场景，更新一条语句时，条件中唯一索引和普通索引哪个选择更好的，为什么"></a>mysql 写多读少场景，更新一条语句时，条件中唯一索引和普通索引哪个选择更好的，为什么</h4><p>本质想问的是 mysql change buffer</p>
<p>入门：<a href="https://www.cnblogs.com/myseries/p/11307204.html" target="_blank" rel="noopener">https://www.cnblogs.com/myseries/p/11307204.html</a><br>入门：<a href="https://www.modb.pro/db/112469" target="_blank" rel="noopener">https://www.modb.pro/db/112469</a><br>深入：<a href="https://www.modb.pro/db/50671" target="_blank" rel="noopener">https://www.modb.pro/db/50671</a></p>
<h4 id="Change-buffer-与-Buffer-Pool-的区别"><a href="#Change-buffer-与-Buffer-Pool-的区别" class="headerlink" title="Change buffer 与 Buffer Pool 的区别"></a>Change buffer 与 Buffer Pool 的区别</h4><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><h4 id="幻读的解决"><a href="#幻读的解决" class="headerlink" title="幻读的解决"></a>幻读的解决</h4><p>资料：<a href="https://relph1119.github.io/mysql-learning-notes/#/" target="_blank" rel="noopener">MySQL 是怎样运行的：从根儿上理解 MySQL</a></p>
<h4 id="sql语句加锁分析"><a href="#sql语句加锁分析" class="headerlink" title="sql语句加锁分析"></a>sql语句加锁分析</h4><h5 id="1-普通select（也叫一致性读）语句加锁分析"><a href="#1-普通select（也叫一致性读）语句加锁分析" class="headerlink" title="1.普通select（也叫一致性读）语句加锁分析"></a>1.普通select（也叫一致性读）语句加锁分析</h5><h5 id="2-特殊select（也叫锁定读-in-shard-mode-and-for-update-）语句加锁分析"><a href="#2-特殊select（也叫锁定读-in-shard-mode-and-for-update-）语句加锁分析" class="headerlink" title="2.特殊select（也叫锁定读(in shard mode and for update)）语句加锁分析"></a>2.特殊select（也叫锁定读(in shard mode and for update)）语句加锁分析</h5><h5 id="3-update-and-delete语句时加锁分析"><a href="#3-update-and-delete语句时加锁分析" class="headerlink" title="3.update and delete语句时加锁分析"></a>3.update and delete语句时加锁分析</h5><p><a href="https://stackoverflow.com/questions/26215071/rationale-behind-difference-between-unique-and-non-unique-indexes-in-mysql-innod?rq=1" target="_blank" rel="noopener">Rationale behind difference between unique and non-unique indexes in MySQL InnoDB next-key locking</a></p>
<p><a href="https://mp.weixin.qq.com/s/ODbju9fjB5QFEN8IIYp__A" target="_blank" rel="noopener">超全面MySQL语句加锁分析（中篇）我们都是小青蛙</a></p>
<p><a href="https://relph1119.github.io/mysql-learning-notes/#/mysql/26-%E5%86%99%E4%BD%9C%E6%9C%AC%E4%B9%A6%E6%97%B6%E7%94%A8%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99" target="_blank" rel="noopener">我们都是小青蛙推荐的文章和博客</a></p>
<p><a href="https://github.com/hedengcheng/tech/blob" target="_blank" rel="noopener">何登成的github</a></p>
<p><a href="https://www.cnblogs.com/rjzheng/p/9950951.html" target="_blank" rel="noopener">惊！史上最全的select加锁分析(Mysql)</a></p>
<h4 id="mysql事务是如何实现的，回滚时是怎么个操作流程，"><a href="#mysql事务是如何实现的，回滚时是怎么个操作流程，" class="headerlink" title="mysql事务是如何实现的，回滚时是怎么个操作流程，"></a>mysql事务是如何实现的，回滚时是怎么个操作流程，</h4><p>事务实现的原理，我认为便是事务如何保证ACID，即原子性，一致性，隔离性，持久性。</p>
<p>也即是想问redo，undo的知识点</p>
<h4 id="mysql为什么使用B-树，而mongdb使用B树呢"><a href="#mysql为什么使用B-树，而mongdb使用B树呢" class="headerlink" title="mysql为什么使用B+树，而mongdb使用B树呢"></a>mysql为什么使用B+树，而mongdb使用B树呢</h4><h4 id="mysql主从的实现方式，哪些方式"><a href="#mysql主从的实现方式，哪些方式" class="headerlink" title="mysql主从的实现方式，哪些方式"></a>mysql主从的实现方式，哪些方式</h4><p><a href="https://www.cnblogs.com/rickiyang/p/13856388.html" target="_blank" rel="noopener">https://www.cnblogs.com/rickiyang/p/13856388.html</a></p>
<h4 id="mysql是怎样运行的小结"><a href="#mysql是怎样运行的小结" class="headerlink" title="mysql是怎样运行的小结"></a>mysql是怎样运行的小结</h4><h4 id="redo-log-amp-binlog-amp-undo-log写入数据的顺序和具体流程-自问"><a href="#redo-log-amp-binlog-amp-undo-log写入数据的顺序和具体流程-自问" class="headerlink" title="redo log &amp; binlog &amp; undo log写入数据的顺序和具体流程  自问"></a>redo log &amp; binlog &amp; undo log写入数据的顺序和具体流程  自问</h4><p><a href="https://xiaolincoding.com/mysql/log/how_update.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-undo-log" target="_blank" rel="noopener">https://xiaolincoding.com/mysql/log/how_update.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-undo-log</a></p>
<h5 id="bufferPool-redo日志-undo日志-分别何时产生，何时刷盘，何时删除"><a href="#bufferPool-redo日志-undo日志-分别何时产生，何时刷盘，何时删除" class="headerlink" title="bufferPool redo日志 undo日志 分别何时产生，何时刷盘，何时删除"></a>bufferPool redo日志 undo日志 分别何时产生，何时刷盘，何时删除</h5><p>因为只有改动才会涉及redo，undo。所以假设执行的 update 语句</p>
<p>redo log + undo log的简化版本过程<br>redo log是用来恢复数据的，用于保障已提交事务的持久性；<br>undo log是用来回滚事务的，用于保障未提交事务的原子性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 查询的数据若在Buffer Pool存在，则直接使用，不存在则读取磁盘中的数据并放入Buffer Pool，再使用；</span><br><span class="line">2. 更新操作前，会先将数据的旧值写入undo log，以便回滚。（保证原子性）；</span><br><span class="line">3. 更新的新数据到Buffer Pool（内存:刷盘时机：专门线程每隔一段时间把脏页刷到磁盘：路径1.从LRU链表的冷数据中刷新一部分页面到磁盘；路径2.从flush链表中刷新一部分页面到磁盘）中；</span><br><span class="line">4. 将更新的新数据写入到redo Log Buffer（内存中）；</span><br><span class="line">5. 准备提交事务，会将redo Log Buffer的数据刷到redo log日志文件(即刷到磁盘)(redo log刷盘有四种方式:见redo log 什么时候刷盘)中，此时redo log状态为prepare；</span><br><span class="line">6. 准备提交事务，binlog 日志写入磁盘；</span><br><span class="line">7. binlog写入成功后，将redo log的状态变更为commit；</span><br><span class="line"></span><br><span class="line">5至7步使用了两阶段提交：prepare阶段，commit阶段</span><br></pre></td></tr></table></figure>
<p>举例：update set A=3 where A=1</p>
<ol>
<li>事务开始</li>
<li>记录A=1到undo log</li>
<li>修改A=3</li>
<li>记录A=3到 redo log</li>
<li>事务提交</li>
</ol>
<p>链接：<br><a href="https://www.jianshu.com/p/43fb7bc40648" target="_blank" rel="noopener">https://www.jianshu.com/p/43fb7bc40648</a><br><a href="https://www.jianshu.com/p/dbbd8d601f8c" target="_blank" rel="noopener">https://www.jianshu.com/p/dbbd8d601f8c</a></p>
<p><a href="https://xiaolincoding.com/mysql/log/how_update.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-undo-log" target="_blank" rel="noopener">为什么需要-undo-log 总结部分</a></p>
<p><a href="https://doc.vercel.app/mysql/article/76795.html" target="_blank" rel="noopener">MySQL实战45讲</a></p>
<p><a href="https://juejin.cn/book/6844733769996304392/section/7075316605378363425?enter_from=course_center&amp;utm_source=course_center" target="_blank" rel="noopener">MySQL 是怎样运行的：从根儿上理解 MySQL</a></p>
<h5 id="两个重要的指针-roll-pointor-amp-next-record"><a href="#两个重要的指针-roll-pointor-amp-next-record" class="headerlink" title="两个重要的指针 roll-pointor &amp; next-record"></a>两个重要的指针 roll-pointor &amp; next-record</h5><p>roll_pointor：记录指向它的 undo 日志的指针<br>next_record ：记录指向下一条记录的指针</p>
<h4 id="mysql主从复制延迟解决方案"><a href="#mysql主从复制延迟解决方案" class="headerlink" title="mysql主从复制延迟解决方案"></a>mysql主从复制延迟解决方案</h4><h5 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h5><p>当在从库上启动复制时，首先创建I/O线程连接主库，主库随后创建Binlog Dump线程读取数据库事件并发送给I/O线程，I/O线程获取到事件数据后更新到从库的中继日志Relay Log中去，之后从库上的SQL线程读取中继日志Relay Log中更新的数据库事件并应用，<br>细化一下有如下几个步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、MySQL主库在事务提交时把数据变更（insert、delet、update）作为事件日志记录在二进制日志表（binlog）里面。</span><br><span class="line">2、主库上有一个工作线程 binlog dump thread，把binlog的内容发送到从库的中继日志relay log中。</span><br><span class="line">3、从库根据中继日志relay log重做数据变更操作，通过逻辑复制来达到主库和从库的数据一致性。</span><br><span class="line">4、MySQL通过三个线程来完成主从库间的数据复制，其中binlog dump线程跑在主库上，I/O线程和SQL线程跑在从库上。拥有多个从库的主库会为每一个连接到主库的从库创建一个binlog dump线程。</span><br></pre></td></tr></table></figure>
<h5 id="延迟原因"><a href="#延迟原因" class="headerlink" title="延迟原因"></a>延迟原因</h5><p>MySQL主从复制，读写分离是我们常用的数据库架构，但是在并发量较大、数据变化大的场景下，主从延时会比较严重。 </p>
<p>延迟的本质原因是：<strong>系统TPS并发较高时，主库产生的DML（也包含一部分DDL）数量超过Slave一个Sql线程所能承受的范围，效率就降低了。</strong></p>
<p><strong>我们看到这个sql thread 是单个线程，所以他在重做RelayLog的时候，能力也是有限的。主库是并发的事务提交，但是从库只能串行执行，速度比主库慢</strong> </p>
<h5 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h5><h6 id="分治-分库分表"><a href="#分治-分库分表" class="headerlink" title="分治 - 分库分表"></a>分治 - 分库分表</h6><p>数据库分区是永恒的话题，主从延迟一定程度上是单台数据库主服务操作过于频繁，使得<strong>单线程的SQL thread 疲于应付。</strong>可以适当的从功能上对数据库进行拆分，分担压力。</p>
<h6 id="从库同步完成后响应"><a href="#从库同步完成后响应" class="headerlink" title="从库同步完成后响应"></a>从库同步完成后响应</h6><h6 id="适当引入缓存"><a href="#适当引入缓存" class="headerlink" title="适当引入缓存"></a>适当引入缓存</h6><p>可以引入redis或者其他nosql数据库来存储我们经常会产生主从延迟的业务数据。当我在写入数据库的同时，我们再写入一份到redis中。</p>
<p>读取数据的时候，我们可以<strong>先去查看redis中是否有这个数据，如果有我们就可以直接从redis中读取这个数据。当数据真正同步到数据库中的时候，再从redis中把数据删除。</strong>如下图：</p>
<p><img src="https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20221209200402.png" alt="20221209200402"></p>
<h6 id="多线程重放RelayLog"><a href="#多线程重放RelayLog" class="headerlink" title="多线程重放RelayLog"></a>多线程重放RelayLog</h6><p>MySQL使用单线程重放RelayLog，那能不能在这上面做解法呢，比如使用多线程并行重放RelayLog，就可以缩短时间。但是这个对数据一致性是个考验。</p>
<p>需要考虑如何分割RelayLog，才能够让多个数据库实例，多个线程并行重放RelayLog，不会出现不一致。比如RelayLog包含这三条语句给学生授予学分的记录，你就不知道结果会变成什么。可能是806甚至是721。</p>
<p>相同库表上的写操作，用相同的线程来重放RelayLog；不同库表上的写操作，可以并发用多个线程并发来重放RelayLog。</p>
<p><img src="https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20221209200126.png" alt="20221209200126"></p>
<p>设计一个哈希算法，hash(db-name) % thread-num，表名称hash之后再模上线程数，就能很轻易做到，同一个库表上的写操作，被同一个重放线程串行执行，做到提效的目的。</p>
<h6 id="少量读业务直连主库"><a href="#少量读业务直连主库" class="headerlink" title="少量读业务直连主库"></a>少量读业务直连主库</h6><p>详情：<a href="https://heapdump.cn/article/3314653" target="_blank" rel="noopener">架构与思维：高并发下解决主从延时的一些思路原创</a></p>
<h2 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h2><p>kafka中的消费是基于<strong>拉模式</strong>的</p>
<h3 id="可靠性的保证-kafka如何保证消息的可靠的"><a href="#可靠性的保证-kafka如何保证消息的可靠的" class="headerlink" title="可靠性的保证(kafka如何保证消息的可靠的)"></a>可靠性的保证(kafka如何保证消息的可靠的)</h3><ol>
<li>生产者保证：1.acks确认机制: request.required.acks；2.isr副本集合；3.重试</li>
<li>broker保证：1.副本机制（数据多份）；2.同步机制。leader挂掉，从followers选举一个成为新的leader；3.offset位移提交时机</li>
</ol>
<p>kafka中的消息有三种传递语义：</p>
<ul>
<li>at most once：最多一次。消息可能丢失也可能被处理，但最多只会被处理一次。</li>
<li>at least once：至少一次。消息不会丢失，但可能被处理多次。可能重复，不会丢失。</li>
<li>exactly once：精确传递一次。消息被处理且只会被处理一次。不丢失不重复就一次。</li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/459610418" target="_blank" rel="noopener">进阶，Kafka 如何保证消息不丢失？</a><br><a href="https://xie.infoq.cn/article/d62160c08a5ecb5dca291e159" target="_blank" rel="noopener">刨根问底，kafka 到底会不会丢消息</a><br><a href="https://developer20.com/when-you-can-nose-messages-in-kafka/" target="_blank" rel="noopener">When you can lose messages in Kafka</a></p>
<h4 id="生产者的可靠性保证"><a href="#生产者的可靠性保证" class="headerlink" title="生产者的可靠性保证"></a>生产者的可靠性保证</h4><p>通过acks和min.insync.replicas和unclean.leader.election.enable的配合，保证在Kafka配置为CP系统时，要么不工作，要么得到ack后，消息不会丢失且消息状态一致。</p>
<h5 id="acks策略"><a href="#acks策略" class="headerlink" title="acks策略"></a>acks策略</h5><pre><code>回答生产者的可靠性保证，即回答：
    发消息之后有没有ack？
    发消息收到ack后，是不是消息就不会丢失了？

而Kafka通过配置来指定producer生产者在发送消息时的ack策略：
    Request.required.acks = -1 (全量同步确认，强可靠性保证)；
    Request.required.acks = 1 (leader 确认收到, 默认)；
    Request.required.acks = 0 (不确认，但是吞吐量大)。
</code></pre><h5 id="ISR"><a href="#ISR" class="headerlink" title="ISR"></a>ISR</h5><p>isr = in-sync replica set</p>
<p>所有 Follower 完成同步，Producer 才能继续发送数据，设想有一个 Follower 因为某种原因出现故障，那 Leader 就要一直等到它完成同步。<br>这个问题怎么解决？Leader维护了一个动态的 in-sync replica set（ISR）：和 Leader 保持同步的 Follower 集合。<br>当 ISR 集合中的 Follower 完成数据的同步之后， Follower 就会给 Leader 发送 ACK。<br>如果 Follower 长时间未向 Leader 同步数据，则该 Follower 将被踢出 ISR 集合，该时间阈值由 replica.lag.time.max.ms 参数设定。Leader 发生故障后，就会从 ISR 中选举出新的 Leader。</p>
<h5 id="min-insync-replicas"><a href="#min-insync-replicas" class="headerlink" title="min.insync.replicas"></a>min.insync.replicas</h5><pre><code>参数用于保证当前集群中处于正常同步状态的副本follower数量，当实际值小于配置值时，集群停止服务。如果配置为 N/2+1, 即多一半的数量，则在满足此条件下，通过算法保证强一致性。当不满足配置数时，牺牲可用性即停服。
</code></pre><h5 id="unclean-leader-election-enable"><a href="#unclean-leader-election-enable" class="headerlink" title="unclean.leader.election.enable"></a>unclean.leader.election.enable</h5><pre><code>异常情况下，leader挂掉，此时需要重新从follower选举leader。可以为f2或者f3。
</code></pre><p><img src="https://pic1.zhimg.com/80/v2-cfe4e7eb1070a77fdc24e23c639b6e9c_1440w.jpg" alt=""></p>
<p>如果选举f3为新leader, 则可能会发生消息截断，因为f3还未同步msg4的数据。Kafka通过unclean.leader.election.enable来控制在这种情况下，是否可以选举f3为leader。旧版本中默认为true,在某个版本下已默认为false，避免这种情况下消息截断地出现。</p>
<h5 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h5><p>网络抖动，可以重试<br>消息体过大，broker 拒收</p>
<h5 id="CP-or-AP"><a href="#CP-or-AP" class="headerlink" title="CP or AP"></a>CP or AP</h5><ul>
<li>如果想实现Kafka配置为 CP系统，配置需要如下:</li>
</ul>
<p>request.required.acks=-1<br>min.insync.replicas = ${N/2 + 1}<br>unclean.leader.election.enable = false</p>
<ul>
<li>如果想实现Kafka配置为 AP系统，配置需要如下:</li>
</ul>
<p>request.required.acks=1<br>min.insync.replicas = 1<br>unclean.leader.election.enable = false</p>
<p>思考：分区与副本因子有关系吗，什么关系<br>新的消费(组)进来时，为什么找不到消费位移，不是broker存着呢吗</p>
<h4 id="broker的可靠性保证"><a href="#broker的可靠性保证" class="headerlink" title="broker的可靠性保证"></a>broker的可靠性保证</h4><ul>
<li>副本机制(备份)和同步机制</li>
</ul>
<p>副本机制：Kafka通过分区的多副本策略来解决消息的备份问题；同步机制：同时通过HW和LEO的标识，通过ISR和OSR的概念，一起解决数据同步一致性的问题。</p>
<h5 id="副本机制"><a href="#副本机制" class="headerlink" title="副本机制"></a>副本机制</h5><p>Kafka通过分区多副本即前文提到的Partition 的replica(副本) 分布在跟 partition 不相同的机器上，达到数据冗余。</p>
<h5 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h5><p>消息通过producer发送到broker之后，还会遇到很多问题：<br>    Partition leader 写入成功，follower什么时候同步？<br>    Leader写入成功，消费者什么时候能读到这条消息？<br>    Leader写入成功后，leader重启，重启后消息状态还正常吗？<br>    Leader重启，如何选举新的leader？<br>这些问题集中在：消息落到broker后，集群通过何种机制来保证不同副本间的消息状态一致性。</p>
<p>不同副本的状态同步形成了同步机制。同步机制涉及了AR、ISR、OSR、HW和LEO等概念。<br>而 ISR 集合中最小的 LEO 即为分区的 HW，对消费者而言只能消费 HW 之前的消息。LEO: Log End Offset</p>
<p><a href="https://zhuanlan.zhihu.com/p/302704003" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/302704003</a></p>
<h3 id="offset详解"><a href="#offset详解" class="headerlink" title="offset详解"></a>offset详解</h3><p>对于分区来说是偏移量，对于消费者是位移</p>
<p>位移提交时机是难点</p>
<p><a href="https://www.jianshu.com/p/449074d97daf" target="_blank" rel="noopener">Kafka offset管理</a></p>
<h3 id="生产者发送消息到broker的过程"><a href="#生产者发送消息到broker的过程" class="headerlink" title="生产者发送消息到broker的过程"></a>生产者发送消息到broker的过程</h3><h3 id="消费者从broker消费消息的过程"><a href="#消费者从broker消费消息的过程" class="headerlink" title="消费者从broker消费消息的过程"></a>消费者从broker消费消息的过程</h3><h3 id="kafka-offset存在哪里，为啥用kafka不是其他消息组件，他最大能支持多少并发，如何保证消息的可靠的"><a href="#kafka-offset存在哪里，为啥用kafka不是其他消息组件，他最大能支持多少并发，如何保证消息的可靠的" class="headerlink" title="kafka offset存在哪里，为啥用kafka不是其他消息组件，他最大能支持多少并发，如何保证消息的可靠的"></a>kafka offset存在哪里，为啥用kafka不是其他消息组件，他最大能支持多少并发，如何保证消息的可靠的</h3><p>offset 存在 Broker 中</p>
<h3 id="kafka-是如何保证消息可靠的"><a href="#kafka-是如何保证消息可靠的" class="headerlink" title="kafka 是如何保证消息可靠的"></a>kafka 是如何保证消息可靠的</h3><p>在以下三步中每一步都可能会出现丢失数据的情况，那么 Kafka 到底在什么情况下才能保证消息不丢失呢？</p>
<h4 id="1）Producer-端发送消息给-Kafka-Broker-端。"><a href="#1）Producer-端发送消息给-Kafka-Broker-端。" class="headerlink" title="1）Producer 端发送消息给 Kafka Broker 端。"></a>1）Producer 端发送消息给 Kafka Broker 端。</h4><h5 id="丢消息场景："><a href="#丢消息场景：" class="headerlink" title="丢消息场景："></a>丢消息场景：</h5><p>Producer 端为了提升发送效率，减少IO操作，发送数据的时候是将多个请求合并成一个个 RecordBatch，并将其封装转换成 Request 请求「异步」将数据发送出去（也可以按时间间隔方式，达到时间间隔自动发送），所以 Producer 端<strong>消息丢失更多是因为消息根本就没有发送到 Kafka Broker 端。</strong></p>
<p>导致 Producer 端消息没有发送成功有以下原因：</p>
<ol>
<li>网络原因：由于网络抖动导致数据根本就没发送到 Broker 端。</li>
<li>数据原因：消息体太大超出 Broker 承受范围而导致 Broker 拒收消息。</li>
</ol>
<p>producer 即使配置 ack 也可能丢消息：broker 挂了，producer 没有收到 ack</p>
<ol>
<li><p>acks =0：由于发送后就自认为发送成功，这时如果发生网络抖动， Producer 端并不会校验 ACK 自然也就丢了，且无法重试。</p>
</li>
<li><p>acks = 1：消息发送 Leader Parition 接收成功就表示发送成功，这时只要 Leader Partition 不 Crash 掉，就可以保证 Leader Partition 不丢数据，但是如果 Leader Partition 异常 Crash 掉了，Follower Partition 还未同步完数据且没有 ACK，这时就会丢数据。</p>
</li>
<li><p>acks = -1 或者 all：消息发送需要等待 ISR 中 Leader Partition 和 所有的 Follower Partition 都确认收到消息才算发送成功，可靠性最高，但也不能保证不丢数据，比如当 ISR 中只剩下 Leader Partition 了，这样就变成 acks = 1 的情况了。</p>
</li>
</ol>
<h5 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h5><p>（1）网络抖动导致消息丢失，Producer 端可以进行重试。producer 端配置重试次数 retries 和 重试时间 retry.backoff.ms<br>这样 Producer 端就会一直进行重试直到 Broker 端返回 ACK 标识，同时只有一个连接向 Broker 发送数据保证了消息的顺序性。</p>
<p>（2）消息大小不合格，可以进行适当调整，符合 Broker 承受范围再发送。</p>
<h4 id="2）Kafka-Broker-将消息进行同步并持久化数据。"><a href="#2）Kafka-Broker-将消息进行同步并持久化数据。" class="headerlink" title="2）Kafka Broker 将消息进行同步并持久化数据。"></a>2）Kafka Broker 将消息进行同步并持久化数据。</h4><p>在剖析Broker 端丢失场景的时候， 我们得出其是通过「异步批量刷盘」的策略，先将数据存储到「PageCache」，再进行异步刷盘， 由于没有提供 「同步刷盘」策略，因此 Kafka 是通过「多分区多副本」的方式来最大限度的保证数据不丢失。</p>
<p>我们可以通过以下参数配合来保证：</p>
<p>4.2.1 unclean.leader.election.enable：<br>该参数表示有哪些 Follower 可以有资格被选举为 Leader , 如果一个 Follower 的数据落后 Leader 太多，那么一旦它被选举为新的 Leader， 数据就会丢失，因此我们要将其设置为false，防止此类情况发生。</p>
<p>4.2.2 replication.factor：<br>该参数表示分区副本的个数。建议设置replication.factor &gt;=3, 这样如果 Leader 副本异常 Crash 掉，Follower 副本会被选举为新的 Leader 副本继续提供服务。</p>
<p>4.2.3 min.insync.replicas：<br>该参数表示消息至少要被写入成功到 ISR 多少个副本才算”已提交”，建议设置min.insync.replicas &gt; 1,这样才可以提升消息持久性，保证数据不丢失。</p>
<p>另外我们还需要确保一下replication.factor &gt; min.insync.replicas, 如果相等，只要有一个副本异常 Crash 掉，整个分区就无法正常工作了，因此推荐设置成：replication.factor =min.insync.replicas +1, 最大限度保证系统可用性。</p>
<h4 id="3）Consumer-端从Kafka-Broker-将消息拉取并进行消费。"><a href="#3）Consumer-端从Kafka-Broker-将消息拉取并进行消费。" class="headerlink" title="3）Consumer 端从Kafka Broker 将消息拉取并进行消费。"></a>3）Consumer 端从Kafka Broker 将消息拉取并进行消费。</h4><p>在剖析 Consumer 端丢失场景的时候，我们得出其拉取完消息后是需要提交 Offset 位移信息的，因此为了不丢数据，正确的做法是：拉取数据、业务逻辑处理、提交消费 Offset 位移信息。</p>
<p>我们还需要设置参数enable.auto.commit = false, 采用手动提交位移的方式。</p>
<p>另外对于消费消息重复的情况，业务自己保证幂等性, 保证只成功消费一次即可。</p>
<h5 id="消费者如何保证一定成功消费消息-重试实现"><a href="#消费者如何保证一定成功消费消息-重试实现" class="headerlink" title="消费者如何保证一定成功消费消息 - 重试实现"></a>消费者如何保证一定成功消费消息 - 重试实现</h5><p>这里已kafka 为例</p>
<h6 id="kafka-消费重试实现"><a href="#kafka-消费重试实现" class="headerlink" title="kafka 消费重试实现"></a>kafka 消费重试实现</h6><p>实际场景：消费者服务中，接收了一个消息，但消费者服务自身业务逻辑处理异常了，相当于消息消费失败了。消费者需要重新消费这条消息，重新走业务逻辑。如何解决这个场景呢</p>
<h6 id="代码里重试"><a href="#代码里重试" class="headerlink" title="代码里重试"></a>代码里重试</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int i = 0</span><br><span class="line">try&#123;</span><br><span class="line">    // 处理业务逻辑</span><br><span class="line">&#125; catch() &#123;</span><br><span class="line">    while(i&lt;3) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        // 重新处理业务逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点：重试间隔时间没有，代码侵入性高</p>
<h6 id="offset重置"><a href="#offset重置" class="headerlink" title="offset重置"></a>offset重置</h6><p>在消息消费失败时，SeekToCurrentErrorHandler 会将 调用 Kafka Consumer 的 seek(TopicPartition partition, long offset) 方法，将 Consumer 对于该消息对应的 TopicPartition 分区的本地进度设置成该消息的位置。</p>
<p>缺点：影响重置位置后面的已经成功消费的消息了</p>
<p>参考：<a href="https://cloud.tencent.com/developer/article/1863357" target="_blank" rel="noopener">Apache Kafka-消费端消费重试和死信队列</a></p>
<h6 id="基于数据库任务表的扫描"><a href="#基于数据库任务表的扫描" class="headerlink" title="基于数据库任务表的扫描"></a>基于数据库任务表的扫描</h6><p>在数据库中增加一个任务的状态表，然后用一个定时任务去扫描任务表中，失败的任务，然后进行重试，其中记录下重试的次数即可<br>优点：实现简单，一般这种离线任务，根据统计的需求，都会有一个任务状态表的，所以仅仅是增加一个定时任务去扫表<br>缺点：性能较差，定时任务，一般都在无意义的扫描，浪费性能</p>
<h6 id="新增重试队列-创建一个重试topic"><a href="#新增重试队列-创建一个重试topic" class="headerlink" title="新增重试队列 - 创建一个重试topic"></a>新增重试队列 - 创建一个重试topic</h6><p>失败的消息写入主题’main_topic’中，如果此消息的处理失败，那么我们应该在5分钟内再次尝试。我们怎么做？我们应该向’retry_topic’写一条新消息，它包装失败的消息并添加2个字段：</p>
<ol>
<li>‘retry_number’，值为1</li>
<li>‘retry_timestamp’，其值计算为现在+ 5分钟<br>这意味着’main_topic’使用者将失败的消息处理的责任委托给另一个组件。’main_topic’消费者未被阻止，可以接收下一条消息。’retry_topic’消费者将立即收到’main_topic’消费者发布的消息。它必须从消息中读取’retry_timestamp’值并等到那一刻，阻塞线程。线程唤醒后，它将再次尝试处理该消息。如果成功，那么我们可以获取下一个可用消息。否则我们必须再次尝试。我们要做的是克隆消息，递增’attempt_number’值（它将为2）并将’retry_timestamp’值设置为now + 5分钟。消息克隆将再次发布到’retry__topic。<br>如果我们到达重试最高次数。现在是时候说“停止”了。我们将消息写入’failed_topic’并将此消息视为未处理。有人必须手动处理它。</li>
</ol>
<p><a href="https://www.cnblogs.com/xiaohanlin/p/12430173.html" target="_blank" rel="noopener">kafka 消费重试 实现 </a></p>
<p><a href="https://blog.rubinchu.com/2021/12/02/kafka%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B9%8B%E9%87%8D%E8%AF%95%E9%98%9F%E5%88%97/" target="_blank" rel="noopener">Kafka高级特性之重试队列</a></p>
<h3 id="kafka-rebalance"><a href="#kafka-rebalance" class="headerlink" title="kafka rebalance"></a>kafka rebalance</h3><p><a href="https://www.cnblogs.com/chanshuyi/p/kafka_rebalance_quick_guide.html" target="_blank" rel="noopener">线上Kafka突发rebalance异常，如何快速解决</a></p>
<h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><ul>
<li>消费者心跳超时，导致 rebalance。</li>
<li>消费者处理时间过长，导致 rebalance。</li>
</ul>
<h4 id="rebalance时间长原因"><a href="#rebalance时间长原因" class="headerlink" title="rebalance时间长原因"></a>rebalance时间长原因</h4><ol>
<li>Consumers needs to finish processing the data they polled last time.</li>
<li>Coordinator waits for Consumer to send JoinGroup request - for how long?</li>
<li>Consumers send SyncGroup request (is there a delay between receiving JoinGroup response and sending SyncGroup request?)</li>
</ol>
<h4 id="有关参数"><a href="#有关参数" class="headerlink" title="有关参数"></a>有关参数</h4><p>要学会处理 rebalance 问题，我们需要先搞清楚 kafaka 消费者配置的四个参数：</p>
<ul>
<li>session.timeout.ms 设置了超时时间</li>
<li>heartbeat.interval.ms 心跳时间间隔</li>
<li>max.poll.interval.ms 每次消费的处理时间</li>
<li>max.poll.records 每次消费的消息数</li>
</ul>
<p><code>session.timeout.ms</code> 表示 consumer 向 broker 发送心跳的超时时间。例如 <code>session.timeout.ms</code> = 180000 表示在最长 180 秒内 broker 没收到 consumer 的心跳，那么 broker 就认为该 consumer 死亡了，会启动 rebalance。</p>
<p><code>heartbeat.interval.ms</code> 表示 consumer 每次向 broker 发送心跳的时间间隔。<code>heartbeat.interval.ms</code> = 60000 表示 consumer 每 60 秒向 broker 发送一次心跳。一般来说，<code>session.timeout.ms</code> 的值是 <code>heartbeat.interval.ms</code> 值的 3 倍以上。</p>
<p><code>max.poll.interval.ms</code> 表示 consumer 每两次 poll 消息的时间间隔。简单地说，其实就是 consumer 每次消费消息的时长。如果消息处理的逻辑很重，那么市场就要相应延长。否则如果时间到了 consumer 还么消费完，broker 会默认认为 consumer 死了，发起 rebalance。</p>
<p><code>max.poll.records</code> 表示每次消费的时候，获取多少条消息。获取的消息条数越多，需要处理的时间越长。所以每次拉取的消息数不能太多，需要保证在 <code>max.poll.interval.ms</code> 设置的时间内能消费完，否则会发生 rebalance。</p>
<p>简单来说，会导致崩溃的几个点是：</p>
<p>消费者心跳超时，导致 rebalance。<br>消费者处理时间过长，导致 rebalance。</p>
<h4 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h4><ol>
<li>增大<code>session.timeout.ms</code>值，增大<code>max.poll.interval.ms</code>值，减小<code>max.poll.records</code>值</li>
<li>take advantage of Kafka’s <strong><code>static group membership</code></strong>, which was made available as of Apache Kafka 2.3 This is the group.instance.id setting for consumers, set uniquely on each consumer within a group</li>
<li>enable <strong><code>incremental cooperative rebalance protocol</code></strong> instead of the default “stop the world” protocol. With incremental cooperative rebalancing (set on the consumers’ configuration as partition.assignment.strategy: ”cooperative-sticky”), available for consumers as of Apache Kafka 2.4,</li>
</ol>
<p><a href="https://www.verica.io/blog/understanding-kafkas-consumer-group-rebalancing/" target="_blank" rel="noopener">understanding-kafkas-consumer-group-rebalancing</a></p>
<p><a href="https://medium.com/bakdata/solving-my-weird-kafka-rebalancing-problems-c05e99535435" target="_blank" rel="noopener">solving-my-weird-kafka-rebalancing-problems</a></p>
<h3 id="kafka-有序性"><a href="#kafka-有序性" class="headerlink" title="kafka 有序性"></a>kafka 有序性</h3><h4 id="producer发送消息的有序性"><a href="#producer发送消息的有序性" class="headerlink" title="producer发送消息的有序性"></a>producer发送消息的有序性</h4><p>broker维护一个单调递增的Sequence Number<br>详情：<a href="https://www.cnblogs.com/shujiying/p/14540753.html" target="_blank" rel="noopener">Kafka如何保证消息的顺序性</a></p>
<ol>
<li>使用一个分区 - 实现简单，但有热点瓶颈问题</li>
<li>多个分区，某类数据(如同一个订单)发送到同一分区</li>
</ol>
<h4 id="consumer多线程消费消息，如何保证消息消费有序性"><a href="#consumer多线程消费消息，如何保证消息消费有序性" class="headerlink" title="consumer多线程消费消息，如何保证消息消费有序性"></a>consumer多线程消费消息，如何保证消息消费有序性</h4><p>消费者端创建多个内存队列，同类数据(同一个订单id)都路由到同一个内存队列；然后每个线程分别消费一个内存队列即可，这样就能保证顺序性。<br>详情：<a href="https://www.cnblogs.com/shujiying/p/14540753.html" target="_blank" rel="noopener">Kafka如何保证消息的顺序性</a></p>
<p>如果要全局有序性，则消息放入队列，多线程从一个队列拿消息，拿到消息，处理成功后从队列中删除</p>
<h2 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h2><h3 id="spring-boot"><a href="#spring-boot" class="headerlink" title="spring boot"></a>spring boot</h3><p><a href="https://juejin.cn/post/7146458376505917447" target="_blank" rel="noopener">聊透Spring循环依赖</a></p>
<p><a href="https://www.zhihu.com/question/438247718" target="_blank" rel="noopener">Spring 是如何解决循环依赖的？</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1497692" target="_blank" rel="noopener">一文告诉你Spring是如何利用”三级缓存”巧妙解决Bean的循环依赖问题的</a></p>
<h3 id="spring-cloud"><a href="#spring-cloud" class="headerlink" title="spring cloud"></a>spring cloud</h3><p><a href="https://codeantenna.com/a/bSVHtJenGw" target="_blank" rel="noopener">Eureka节点信息同步延迟及单个注册中心节点load偏高问题的排查</a></p>
<p><a href="https://www.jianshu.com/p/42b0d7351760" target="_blank" rel="noopener">Spring Cloud——Eureka多级缓存机制</a></p>
<h2 id="接口幂等性"><a href="#接口幂等性" class="headerlink" title="接口幂等性"></a>接口幂等性</h2><p><a href="https://juejin.cn/post/6894624582091669517" target="_blank" rel="noopener">什么是接口的幂等性，如何实现接口幂等性？一文搞定</a><br><a href="https://segmentfault.com/a/1190000039737646" target="_blank" rel="noopener">高并发下如何保证接口的幂等性？</a></p>
<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p>经典大神<a href="https://www.youtube.com/watch?v=r2WZNaFyrbQ&amp;list=PL6RdenZrxrw9inR-IJv-erlOKRHjymxMN&amp;index=1" target="_blank" rel="noopener">斯坦福大学 Introduction to Computer Networking CS 144</a></p>
<p><a href="https://cs144.github.io/" target="_blank" rel="noopener">CS 144: Introduction to Computer Networking</a></p>
<p><a href="https://github.com/huangrt01/CS-Notes" target="_blank" rel="noopener">https://github.com/huangrt01/CS-Notes</a><br><a href="https://github.com/huangrt01/CS-Notes/blob/master/Notes/Output/Computer-Networking-A-Top-Down-Approach.md" target="_blank" rel="noopener">https://github.com/huangrt01/CS-Notes/blob/master/Notes/Output/Computer-Networking-A-Top-Down-Approach.md</a><br><a href="https://github.com/moranzcw/Computer-Networking-A-Top-Down-Approach-NOTES" target="_blank" rel="noopener">Wireshark实验文档的翻译和解答。</a><br><a href="https://kiprey.github.io/tags/CS144/" target="_blank" rel="noopener">CS144</a><br><a href="https://www.cnblogs.com/kangyupl/p/stanford_cs144_labs.html" target="_blank" rel="noopener">计算机网络】Stanford CS144 Lab</a><br><a href="http://doraemonzzz.com/tags/CS144/" target="_blank" rel="noopener">CS144 Lab 翻译</a></p>
<h2 id="io"><a href="#io" class="headerlink" title="io"></a>io</h2><h3 id="同步异步"><a href="#同步异步" class="headerlink" title="同步异步"></a>同步异步</h3><h4 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h4><p>目前unix存在五种IO模型(这也和上一篇文章：Unix IO 模型 中提到的一致)，分别是：</p>
<ul>
<li>阻塞型 IO(blocking I/O)</li>
<li>非阻塞性IO(nonblocking I/O)</li>
<li>IO多路复用(I/O multiplexing)</li>
<li>信号驱动IO(signal driven I/O)</li>
<li>异步IO(asynchronous I/O)</li>
</ul>
<h4 id="IO的两个阶段"><a href="#IO的两个阶段" class="headerlink" title="IO的两个阶段"></a>IO的两个阶段</h4><ul>
<li>等待数据准备好</li>
<li>将数据从内核缓冲区复制到用户进程缓冲区</li>
</ul>
<h4 id="同步，异步的区别"><a href="#同步，异步的区别" class="headerlink" title="同步，异步的区别"></a>同步，异步的区别</h4><p>那么究竟什么是同步和异步的区别呢？请重点读一下原文6.2节中的信号驱动IO和异步IO中的比较。最后总结出来是：</p>
<ul>
<li>同步IO，需要用户进程主动将存放在内核缓冲区中的数据拷贝到用户进程中。</li>
<li>异步IO，内核会自动将数据从内核缓冲区拷贝到用户缓冲区，然后再通知用户。</li>
</ul>
<p>这样，同步和异步的概念就非常明显了。以上的五种IO模型，前面四种都是同步的，只有第五种IO模型才是异步的IO。</p>
<h4 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h4><p><img src="https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20230310110434.png" alt="20230310110434"></p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ul>
<li>判断IO是同步还是异步，是看谁主动将数据拷贝到用户进程。</li>
<li>select或者poll，epoll，是同步调用，进行此调用的用户进程也处于阻塞状态。</li>
</ul>
<p><a href="https://blogread.cn/it/article/4108?f=wb" target="_blank" rel="noopener">关于IO的同步,异步,阻塞,非阻塞</a><br><a href="https://tech.meituan.com/2016/11/04/nio.html" target="_blank" rel="noopener">Java NIO浅析</a></p>
<h3 id="tcp-ip-网络"><a href="#tcp-ip-网络" class="headerlink" title="tcp/ip 网络"></a>tcp/ip 网络</h3><p><a href="https://www.bilibili.com/video/BV1Yk4y1y76r?p=58&amp;share_source=copy_web" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Yk4y1y76r?p=58&amp;share_source=copy_web</a></p>
<p><a href="https://www.bilibili.com/video/BV1Ji4y1M7Y1?p=1" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Ji4y1M7Y1?p=1</a></p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><ul>
<li>二叉树：一个节点有两个子树，一个左子树，一个右子树。</li>
<li>二叉查找树：每个节点都大于他的左子树，同时小于他的右子。查找实现</li>
<li>二叉堆：每个节点都大于他的左右子树</li>
</ul>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>第一遍，看题目，想解法，如果十几分分想不出来直接看题解，看看别人的解法，最好能够默写出来<br>第二遍，自己尝试写出<br>第三遍，隔几天后再次写一下，体会+上自己的优化<br>第四遍，一周过去后，再来一一遍<br>第五遍，复习，例如面试前。 (不一定是五遍，而是要做出来自己的体会和思考才是最重要的。) 如果有小手指，帮忙点点。上面的方法是收到，覃超老师的指导的方法。<br>下面推一波，自己使用觉得非常好的刻意练习的工具： 推荐notion辅助我们刻意练习，使用了一个月多，感觉这app真心不错，学习和工作都能用起来。 通过下面的链接，注册一个账号玩一下吧：</p>
<p><a href="https://www.notion.so/?r=8fa23ab14e76405daa2e6efb38569c1b" target="_blank" rel="noopener">https://www.notion.so/?r=8fa23ab14e76405daa2e6efb38569c1b</a></p>
<p>入门视频： <a href="https://www.bilibili.com/video/BV1gQ4y1K76r" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1gQ4y1K76r</a> </p>
<p>入门搭建的自己的home page： <a href="https://www.bilibili.com/video/BV1Zb411H7xC" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Zb411H7xC</a></p>
<p>附上非常好用的刻意练习模板，也是目前自己在使用的模板： <a href="https://www.notion.so/Spaced-Repetition-Battleground-c1f738213e8b4bee871999474bb17bf0" target="_blank" rel="noopener">https://www.notion.so/Spaced-Repetition-Battleground-c1f738213e8b4bee871999474bb17bf0</a></p>
<p>从来没有那么喜欢一个工具，因为这个工具真的满足自己目前的学习和工作的需求。 如果你也喜欢一个工具帮助自己管理时间，管理自己的学习，管理自己的博客等等，这里all in one，而且还做的好。缺点就是可能需要梯子，有时候反应不断太快。 <a href="https://www.notion.so/?r=8fa23ab14e76405daa2e6efb38569c1b" target="_blank" rel="noopener">https://www.notion.so/?r=8fa23ab14e76405daa2e6efb38569c1b</a></p>
<p>刻意练习不是简单重复，而是跳出自己的舒适圈，不断扩大自己的舒适圈，同时在练习的过程也是需要不断反馈和改进。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="架构理论"><a href="#架构理论" class="headerlink" title="架构理论"></a>架构理论</h3><h4 id="软件开发中的原则-SOLID"><a href="#软件开发中的原则-SOLID" class="headerlink" title="软件开发中的原则 - SOLID"></a>软件开发中的原则 - SOLID</h4><p><a href="https://pdai.tech/md/dev-spec/spec/dev-th-solid.html#%E5%AE%9A%E4%B9%89" target="_blank" rel="noopener">SOLID</a></p>
<h4 id="分布式理论-CAP"><a href="#分布式理论-CAP" class="headerlink" title="分布式理论 - CAP"></a>分布式理论 - CAP</h4><p><a href="https://pdai.tech/md/dev-spec/spec/dev-th-solid.html#%E5%AE%9A%E4%B9%89" target="_blank" rel="noopener">SOLID</a></p>
<h4 id="分布式理论-BASE"><a href="#分布式理论-BASE" class="headerlink" title="分布式理论 - BASE"></a>分布式理论 - BASE</h4><p><a href="https://pdai.tech/md/dev-spec/spec/dev-th-solid.html#%E5%AE%9A%E4%B9%89" target="_blank" rel="noopener">SOLID</a></p>
<h4 id="事务理论-ACID"><a href="#事务理论-ACID" class="headerlink" title="事务理论 - ACID"></a>事务理论 - ACID</h4><p><a href="https://pdai.tech/md/dev-spec/spec/dev-th-solid.html#%E5%AE%9A%E4%B9%89" target="_blank" rel="noopener">SOLID</a></p>
<h4 id="微服务基础-康威定律"><a href="#微服务基础-康威定律" class="headerlink" title="微服务基础 - 康威定律"></a>微服务基础 - 康威定律</h4><ul>
<li>第一定律:人是复杂得社会动物</li>
<li>第二定律:一口气吃不成胖子，先搞定能搞定的</li>
<li>第三定律:种瓜得瓜，做独立自治的子系统减少沟通成本</li>
</ul>
<p><a href="https://pdai.tech/md/dev-spec/spec/dev-th-solid.html#%E5%AE%9A%E4%B9%89" target="_blank" rel="noopener">SOLID</a></p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p>从用户浏览器到数据库，影响用户请求的所有环节都可以进行性能优化</p>
<ul>
<li>面试被问到的时候，可以边画图边阐述，一个请求从浏览器到数据库整个链路的方式。</li>
</ul>
<ol>
<li>浏览器：浏览器缓存(304:not Modified 200:cache-control max-age:36000)，页面压缩，减少Cookie传输</li>
<li>CDN：将网站静态资源分发至离用户最近的网络服务商机房</li>
<li>应用服务器：本地缓存，分布式缓存，异步，高并发下使用集群</li>
<li>代码：使用多线程，改善内存管理</li>
<li>数据库：索引，缓存，sql优化</li>
</ol>
<h4 id="性能优化指标"><a href="#性能优化指标" class="headerlink" title="性能优化指标"></a>性能优化指标</h4><p>响应时间，TPS，系统性能计数器等</p>
<h4 id="性能优化-三个“要”原则是："><a href="#性能优化-三个“要”原则是：" class="headerlink" title="性能优化 三个“要”原则是："></a>性能优化 三个“要”原则是：</h4><ol>
<li>要优先查最大的性能瓶颈</li>
<li>性能分析要确诊性能问题的根因</li>
<li>性能优化要考虑各种的情况。</li>
<li>足够多的测量</li>
<li>权衡利弊</li>
</ol>
<h4 id="性能优化-三个“不要”的原则是："><a href="#性能优化-三个“不要”的原则是：" class="headerlink" title="性能优化 三个“不要”的原则是："></a>性能优化 三个“不要”的原则是：</h4><ol>
<li>不要做过度的、反常态的优化</li>
<li>不要过早做不成熟的优化</li>
<li>不要做表面的肤浅优化。</li>
</ol>
<p><a href="https://time.geekbang.org/column/article/186373" target="_blank" rel="noopener">性能优化六大原则：三要三不要，快速有效地进行优化</a></p>
<h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><p>可扩展性关注的是<strong>功能需求</strong>。使其快速响应<strong>需求变化</strong></p>
<h4 id="1-预测变化"><a href="#1-预测变化" class="headerlink" title="1. 预测变化"></a>1. 预测变化</h4><ul>
<li>唯一不变的是变化</li>
<li>2年法则</li>
</ul>
<p>对于架构师来说，如何把握预测的程度和提升预测结果的准确性</p>
<h4 id="2-应对变化"><a href="#2-应对变化" class="headerlink" title="2. 应对变化"></a>2. 应对变化</h4><ul>
<li><p>方案一：提炼出“变化层”和“不变化层”</p>
</li>
<li><p>方案二：提炼出“抽象层”和“实现层”</p>
</li>
</ul>
<h4 id="可扩展性-vs-可伸缩性区别"><a href="#可扩展性-vs-可伸缩性区别" class="headerlink" title="可扩展性 vs 可伸缩性区别"></a>可扩展性 vs 可伸缩性区别</h4><p>可伸缩性：面对用户量的增加，采取的一些措施。可伸缩性更偏向系统和服务，如水平伸缩，垂直伸缩。可伸缩性是指系统通过增加或减少硬件水平从而提升或降低系统性能的难易程度。可伸缩性分为scale up和scale out。scale up是指提高单台服务器的硬件水平来提高系统的整体处理能力，可以调整的有CPU，存储，内存等；scale out是指通过增加系统的处理节点的方式来提高系统的整体处理能力。</p>
<p>可扩展性：面对需求量的增加，采取的一些措施。可扩展性更偏向需求，对需求变化的预测，预测变化，应用变化。可扩展性是软件系统应对需求增加或需求变化的能力。</p>
<h3 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h3><p>维基百科：系统的运作时间，工作时间比总时间，一般用百分比表示，例如99.999%（5个9）。<br>关注的是服务总体的持续时间，系统在给定时间内<strong>总体的运行时间</strong>越长，可用性越高。<br>可用性 = 正常运行时间/(正常运行时间 + 停机时间)</p>
<h4 id="可用性度量"><a href="#可用性度量" class="headerlink" title="可用性度量"></a>可用性度量</h4><p>业界通常用几个9来衡量网站的可用性。</p>
<h4 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h4><ol>
<li>架构的高可用：数据和服务的冗余备份及失效转移</li>
<li>应用的高可用：应用无状态时使用负载均衡</li>
<li>服务的高可用：</li>
</ol>
<ul>
<li>分级管理(核心应用和服务优先使用更好地硬件)</li>
<li>超时设置</li>
<li>异步调用：避免一个服务失败导致整个应用请求失败</li>
<li>服务降级</li>
<li>幂等性设计</li>
</ul>
<ol start="4">
<li><p>数据的高可用：数据备份和失效转移，数据备份保证数据有多个副本<br>数据高可用有几个层面的意思：数据持久性，数据可访问性，数据一致性</p>
</li>
<li><p>软件质量保证的高可用</p>
</li>
</ol>
<ul>
<li>自动化测试</li>
<li>预发布验证</li>
<li>代码控制：分支开发，主干发布</li>
<li>自动化发布</li>
<li>灰度发布</li>
</ul>
<ol start="6">
<li>监控</li>
</ol>
<ul>
<li><ol>
<li>数据采集<br>a. 用户日志收集，服务日志收集<br>b. 性能监控<br>c. 运行数据报告</li>
</ol>
</li>
<li><ol start="2">
<li>监控管理<br>a. 报警<br>b. 失效转移<br>c. 自动降级</li>
</ol>
</li>
</ul>
<h3 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h3><p>维基百科：可靠性（Reliability）是指定时间 t 内，产生正式输出的机率。</p>
<p>可靠性（Reliability）是指系统可以<strong>无故障地</strong>持续运行。与可用性相反，可靠性是根据时间间隔而不是任何时刻来进行定义的。<br>可靠性相关的几个指标如下：平均无故障时间，平均修复时间，平均失效时间<br>MTBF(平均修复时间) = 运行时间(小时)/故障次数</p>
<p>我们举个一个例子来说明二者的区别。如果系统在每小时崩溃1ms，那么它的可用性就超过99.9999%，但是它还是高度不可靠，因为它只能无故障运行1小时。与之类似，如果一个系统从来不崩溃，但是每年要停机两星期，那么它是高度可靠的，但是可用性只有96%。</p>
<h3 id="可用性-vs-可靠性区别"><a href="#可用性-vs-可靠性区别" class="headerlink" title="可用性 vs 可靠性区别"></a>可用性 vs 可靠性区别</h3><p>见各自定义<br>链接：<a href="https://www.jianshu.com/p/32925821dbfb" target="_blank" rel="noopener">https://www.jianshu.com/p/32925821dbfb</a></p>
<h3 id="你们那微服务是怎么划-拆-分的"><a href="#你们那微服务是怎么划-拆-分的" class="headerlink" title="你们那微服务是怎么划(拆)分的"></a>你们那微服务是怎么划(拆)分的</h3><h4 id="为什么拆分"><a href="#为什么拆分" class="headerlink" title="为什么拆分"></a>为什么拆分</h4><p>业务系统往微服务化拆分也非常有必要，原因是：</p>
<ul>
<li>随着业务的发展，应用程序本身的复杂度会不断增加，同样会产生熵增现象。</li>
<li>业务系统的功能越来越多，参与开发迭代的人员也越多，多个人维护一个非常庞大的项目，很容易出现问题。</li>
<li>单个应用系统很难实现横向扩容，并且由于服务器资源有限，导致所有的请求都集中请求到某个服务器节点，造成资源消耗过大，使得系统不稳定</li>
<li>测试、部署成本越来越高</li>
</ul>
<p>最终要的是，单个应用在性能上的瓶颈很难突破，也就是说如果我们要支持18000QPS，单个服务节点肯定无法支撑，所以服务拆分的好处，就是可以利用多个计算机阶段组成一个大规模的分布式计算网络，通过网络通信的方式完成一整套业务逻辑。</p>
<h4 id="如何拆分-拆分策略"><a href="#如何拆分-拆分策略" class="headerlink" title="如何拆分 - 拆分策略"></a>如何拆分 - 拆分策略</h4><ol>
<li>基于业务逻辑拆分<br>1.1 领域模型拆分 - 边界性问题<br>数据领域：如商品域和订单域<br>部门组织领域</li>
</ol>
<p>1.2 用户群体拆分</p>
<ol start="2">
<li>基于可扩展拆分<br>系统中变与不变的部分，不变的部分一般是成熟的、通用的服务功能，变的部分一般是改动比较多、满足业务迭代扩展性需要的功能，我们可以将不变的部分拆分出来，作为共用的服务，将变的部分独立出来满足个性化扩展需要。</li>
</ol>
<p>根据二八原则， 系统中经常变动的部分大约只占 20%，而剩下的 80% 基本不变或极少变化，这样的拆分也解决了发布频率过多而影响成熟服务稳定性的问题。</p>
<ol start="3">
<li>基于可靠性拆分<br>3.1 核心模块拆分<br>把一些重要的模块独立放在一个集群上，不与其他模块混用，而这个独立的集群，服务机性能要是最好的。</li>
</ol>
<p>3.2 主次链路拆分<br>在各个业务系统中，其实都会有主次业务链路。主业务链条，完成了业务系统中最核心的那部分工作。而次链路是保证其他基础功能的稳定运行。</p>
<ol start="4">
<li>基于性能需求拆分<br>访问量特别大，访问频率特别高的业务，又要保证高效的响应能力，这些业务对性能的要求特别高。比如积分竞拍、低价秒杀、**抢购。<br>我们要识别出某些超高并发量的业务，尽可能把这部分业务独立拆分出来。这么做的原因非常简单，一个保证满足高性能业务需求，另一个保证业务的独立性，不互相影响。 </li>
</ol>
<p>类似积分竞拍、超低价秒杀、**抢购，对瞬间峰值和计算性能要求是非常高的。这部分的业务如果跟其他通用业务放在一块，一个是可能互相影响，比如某个链路阻塞，会导致雪崩沿调用链向上传递。</p>
<p><a href="https://heapdump.cn/article/3209555" target="_blank" rel="noopener">https://heapdump.cn/article/3209555</a></p>
<ol start="5">
<li>服务拆分还需要根据当前技术团队和公司所处的状态来进行。</li>
</ol>
<p>不需要过分的追求微服务，否则会导致业务逻辑过于分散，技术架构太过负载，再加上团队的基础设施还不够完善，导致整个交付的时间拉长，对公司的发展来说会造成较大的影响。</p>
<ol start="6">
<li>水平拆分与垂直拆分</li>
</ol>
<h3 id="微服务间数据一致性"><a href="#微服务间数据一致性" class="headerlink" title="微服务间数据一致性"></a>微服务间数据一致性</h3><h4 id="理论依据"><a href="#理论依据" class="headerlink" title="理论依据"></a>理论依据</h4><p>BASE理论：核心思想是即使无法做到强一致性，应用应该可以采用合适的方式达到最终一致性</p>
<ul>
<li>❶ 基本可用(Basically Available)：指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。</li>
<li>❷ 软状态(Soft State)：允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。</li>
<li>❸ 最终一致性(Eventual Consistency)：最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。</li>
</ul>
<h4 id="事件通知模式"><a href="#事件通知模式" class="headerlink" title="事件通知模式"></a>事件通知模式</h4><p>主服务完成后将结果通过事件（常常是消息队列）传递给从服务，从服务在接受到消息后进行消费，完成业务，从而达到主服务与从服务间的消息一致性</p>
<p>事件通知模式详细参看：<a href="https://cloud.tencent.com/developer/article/1700245" target="_blank" rel="noopener">微服务下数据一致性 - 事件通知模式-部分</a></p>
<h5 id="同步事件通知"><a href="#同步事件通知" class="headerlink" title="同步事件通知"></a>同步事件通知</h5><p>业务处理与消息发送同步执行，实现逻辑如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bool result = dao.update(data); // 1. 操作数据库</span><br><span class="line">// 操作数据库失败，会抛出异常</span><br><span class="line"></span><br><span class="line">if(result)&#123;                     // 2. 如果数据库操作成功则发送消息</span><br><span class="line">    mq.send(data);</span><br><span class="line">&#125;</span><br><span class="line">// 如果方法执行失败，会抛出异常</span><br></pre></td></tr></table></figure></p>
<h5 id="同步事件通知问题"><a href="#同步事件通知问题" class="headerlink" title="同步事件通知问题"></a>同步事件通知问题</h5><p>主服务自身DB 处理后，发送消息(kafka)到broker，这时候broker要给主服务发ack，但是此时broker已经收到消息了，但回ack 时，网络出问题了。造成broker 已经成功收到消息，但主服务认为broker没有收到，那么主服务就会回滚DB 操作。最后的结果是主服务回滚了，broker 的消息被消费者消费了。</p>
<h5 id="异步事件"><a href="#异步事件" class="headerlink" title="异步事件"></a>异步事件</h5><p>为了解决上述同步事件中描述的同步事件的问题，异步事件通知模式被发展了出来，既业务服务和事件服务解耦，事件异步进行，由单独的事件服务保证事件的可靠投递。</p>
<h6 id="本地事件服务"><a href="#本地事件服务" class="headerlink" title="本地事件服务"></a>本地事件服务</h6><p>当业务执行时，在同一个本地事务中将事件写入本地事件表，同时投递该事件，如果事件投递成功，则将该事件从事件表中删除。如果投递失败，则使用事件服务定时地异步统一处理投递失败的事件，进行重新投递，直到事件被正确投递，并将事件从事件表中删除。这种方式最大可能地保证了事件投递的实效性，并且当第一次投递失败后，也能使用异步事件服务保证事件至少被投递一次。</p>
<p>然而，这种使用本地事件服务保证可靠事件通知的方式也有它的不足之处，那便是业务仍旧与事件服务有一定耦合（第一次同步投递时），更为严重的是，本地事务需要负责额外的事件表的操作，为数据库带来了压力</p>
<h6 id="外部事件服务"><a href="#外部事件服务" class="headerlink" title="外部事件服务"></a>外部事件服务</h6><p>外部事件服务在本地事件服务的基础上更进了一步，将事件服务独立出主业务服务，主业务服务不在对事件服务有任何强依赖。</p>
<p>业务服务在提交前，向事件服务发送事件，事件服务只记录事件，并不发送。业务服务在提交或回滚后通知事件服务，事件服务发送事件或者删除事件。</p>
<p>但是外部事件服务也有问题：业务系统无法确认是否成功发送事件给事件服务，所以事件服务需要定时向业务系统查询，根据业务系统的返回来决定发送或者删除该事件。也就是对账，对账是最后的防线</p>
<p>以上解决的问题，称为解决微服务数据一致性问题。从另一个角度，生产者消费者的角度，也可以称为是解决了生产者产生的数据如何自身处理成功的同时，将数据一定要发送到消费者那里。那么消费者是如何保证消息一定要消费成功的呢</p>
<h6 id="消费者如何保证一定成功消费消息-重试实现-1"><a href="#消费者如何保证一定成功消费消息-重试实现-1" class="headerlink" title="消费者如何保证一定成功消费消息 - 重试实现"></a>消费者如何保证一定成功消费消息 - 重试实现</h6><p>这里已kafka 为例</p>
<ol>
<li><p>kafka 消费重试实现<br>实际场景：消费者服务中，接收了一个消息，但消费者服务自身业务逻辑处理异常了，相当于消息消费失败了。消费者需要重新消费这条消息，重新走业务逻辑。如何解决这个场景呢</p>
</li>
<li><p>代码里重试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int i = 0</span><br><span class="line">try&#123;</span><br><span class="line">    // 处理业务逻辑</span><br><span class="line">&#125; catch() &#123;</span><br><span class="line">    while(i&lt;3) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        // 重新处理业务逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>缺点：重试间隔时间没有，代码侵入性高</p>
<ol start="3">
<li>offset重置<br>在消息消费失败时，SeekToCurrentErrorHandler 会将 调用 Kafka Consumer 的 seek(TopicPartition partition, long offset) 方法，将 Consumer 对于该消息对应的 TopicPartition 分区的本地进度设置成该消息的位置。</li>
</ol>
<p>缺点：影响重置位置后面的已经成功消费的消息了</p>
<p>参考：<a href="https://cloud.tencent.com/developer/article/1863357" target="_blank" rel="noopener">Apache Kafka-消费端消费重试和死信队列</a></p>
<ol start="4">
<li>基于数据库任务表的扫描</li>
</ol>
<p>在数据库中增加一个任务的状态表，然后用一个定时任务去扫描任务表中，失败的任务，然后进行重试，其中记录下重试的次数即可<br>优点：实现简单，一般这种离线任务，根据统计的需求，都会有一个任务状态表的，所以仅仅是增加一个定时任务去扫表<br>缺点：性能较差，定时任务，一般都在无意义的扫描，浪费性能</p>
<ol start="5">
<li>新增重试队列 - 创建一个重试topic</li>
</ol>
<p>失败的消息写入主题’main_topic’中，如果此消息的处理失败，那么我们应该在5分钟内再次尝试。我们怎么做？我们应该向’retry_topic’写一条新消息，它包装失败的消息并添加2个字段：</p>
<ul>
<li>‘retry_number’，值为1</li>
<li>‘retry_timestamp’，其值计算为现在+ 5分钟<br>这意味着’main_topic’使用者将失败的消息处理的责任委托给另一个组件。’main_topic’消费者未被阻止，可以接收下一条消息。’retry_topic’消费者将立即收到’main_topic’消费者发布的消息。它必须从消息中读取’retry_timestamp’值并等到那一刻，阻塞线程。线程唤醒后，它将再次尝试处理该消息。如果成功，那么我们可以获取下一个可用消息。否则我们必须再次尝试。我们要做的是克隆消息，递增’attempt_number’值（它将为2）并将’retry_timestamp’值设置为now + 5分钟。消息克隆将再次发布到’retry__topic。<br>如果我们到达重试最高次数。现在是时候说“停止”了。我们将消息写入’failed_topic’并将此消息视为未处理。有人必须手动处理它。</li>
</ul>
<p><a href="https://www.cnblogs.com/xiaohanlin/p/12430173.html" target="_blank" rel="noopener">kafka 消费重试 实现 </a></p>
<p><a href="https://blog.rubinchu.com/2021/12/02/kafka%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B9%8B%E9%87%8D%E8%AF%95%E9%98%9F%E5%88%97/" target="_blank" rel="noopener">Kafka高级特性之重试队列</a></p>
<h3 id="服务如何做到高可用"><a href="#服务如何做到高可用" class="headerlink" title="服务如何做到高可用"></a>服务如何做到高可用</h3><h3 id="服务如何做到高并发"><a href="#服务如何做到高并发" class="headerlink" title="服务如何做到高并发"></a>服务如何做到高并发</h3><p><a href="https://learnku.com/laravel/t/24359" target="_blank" rel="noopener">演进</a></p>
<p>首先，我们讲述了如何从0开始，将一个“草根项目”步步重构，最终打造为能抗住亿级流量的强悍系统。<br><a href="https://juejin.cn/post/6844903721793486861" target="_blank" rel="noopener">亿级流量系统架构之如何支撑百亿级数据的存储与计算【石杉的架构笔记】</a></p>
<p>在支撑住了百亿量级的数据存储与计算后，新的问题又来了：系统架构如何避免单点故障？如何设计弹性计算资源调度机制？如何设计高容错机制？新一轮的重构，势在必行<br><a href="https://juejin.cn/post/6844903725249593358" target="_blank" rel="noopener">亿级流量系统架构之如何设计高容错分布式计算系统【石杉的架构笔记】</a></p>
<p>还没完！随着业务的发展，系统将迎来百亿流量的高并发挑战，这时之前的那套架构就有些吃不消了。我们需要做计算与存储的分离、自研纯内存SQL计算引擎、对MQ做削峰以及流量控制、将系统重构为动静分离的架构。新一轮的重构，被业务的发展推上了风口浪尖！<br><a href="https://juejin.cn/post/6844903726050705422" target="_blank" rel="noopener">亿级流量系统架构之如何设计承载百亿流量的高性能架构【石杉的架构笔记】</a></p>
<p>解决上述问题后，查询的问题又来了。我们如何设计能够支撑每秒数十万查询的高并发架构？新一轮重构，自研ElasticSearch+HBase+纯内存的查询引擎，彻底解决每秒10万查询的高并发挑战！<br><a href="https://juejin.cn/post/6844903726835073031" target="_blank" rel="noopener">亿级流量系统架构之如何设计每秒十万查询的高并发架构【石杉的架构笔记】</a></p>
<p>最后，我们要确保设计出来的这套亿级流量架构的高可用！通过设计MQ集群高可用方案、KV集群高可用方案、实时计算链路高可用方案、冷热数据高可用方案、真正保证亿级流量架构全链路99.99%的高可用。<br><a href="https://juejin.cn/post/6844903727699230734" target="_blank" rel="noopener">亿级流量系统架构之如何设计全链路99.99%高可用架构【石杉的架构笔记】</a></p>
<h3 id="服务如何做到高性能"><a href="#服务如何做到高性能" class="headerlink" title="服务如何做到高性能"></a>服务如何做到高性能</h3><p>超高瞬时点赞 收藏如何解决</p>
<p><a href="https://zq99299.github.io/note-architect/hc/07/01.html#%E6%94%AF%E6%92%91%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E8%AE%A1%E6%95%B0%E7%B3%BB%E7%BB%9F%E8%A6%81%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1" target="_blank" rel="noopener">支撑高并发的计数系统要如何设计</a></p>
<h2 id="系统设计-架构设计面试题"><a href="#系统设计-架构设计面试题" class="headerlink" title="系统设计/架构设计面试题"></a>系统设计/架构设计面试题</h2><p><a href="https://www.hiredintech.com/classrooms/system-design/lesson/60" target="_blank" rel="noopener">系统设计的面试</a></p>
<h3 id="系统-架构设计步骤"><a href="#系统-架构设计步骤" class="headerlink" title="系统/架构设计步骤"></a>系统/架构设计步骤</h3><ol>
<li>描述使用场景/用例，明确约束和假设</li>
</ol>
<p>用例：系统有哪些功能<br>约束：限制条件，内存容量，高并发/s，</p>
<ol start="2">
<li>创建一个高层级的设计</li>
</ol>
<p>画图：画出架构：画出主要的组件和连接</p>
<ol start="3">
<li>设计核心组件</li>
</ol>
<p>对每个组件进行详细的分析</p>
<ol start="4">
<li>扩展设计</li>
</ol>
<p>确认和处理瓶颈以及一些限制。举例来说就是你需要下面的这些来完成扩展性的议题吗？</p>
<ul>
<li>负载均衡</li>
<li>水平扩展</li>
<li>缓存</li>
<li>数据库分片</li>
</ul>
<p>论述可能的解决办法和代价。每件事情需要取舍。可以使用可扩展系统的设计原则来处理瓶颈。</p>
<h3 id="如何设计一个秒杀系统"><a href="#如何设计一个秒杀系统" class="headerlink" title="如何设计一个秒杀系统"></a>如何设计一个秒杀系统</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>逻辑简单，难点在于短时间有大量用户进来，短时频繁访问，因此，秒杀系统一定要满足：<code>高并发</code>，<code>高可用</code>，<code>数据一致性</code></p>
<p><img src="https://raw.githubusercontent.com/yaoyuanyy/MarkdownPhotos/master/img/20210817104325.png" alt="20210817104224"></p>
<p>设计秒杀系统的过程中需要重点关注哪些问题</p>
<ol>
<li>参与秒杀的商品属于热点数据，我们该如何处理热点数据？</li>
<li>商品的库存有限，在面对大量订单的情况下，如何解决超卖的问题？</li>
<li>如果系统用了消息队列，如何保证消息队列不丢失消息？</li>
<li>如何保证秒杀系统的高可用？</li>
<li>如何对项目进行压测？有哪些工具？</li>
</ol>
<h4 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h4><p>有大量用户进来，短时频繁访问，如何处理热点数据呢，如秒杀url的获取，秒杀商品详情的获取</p>
<h5 id="秒杀url-动态化"><a href="#秒杀url-动态化" class="headerlink" title="秒杀url - 动态化"></a>秒杀url - 动态化</h5><ul>
<li>在进行秒杀之前，先请求一个服务端地址，/getmiaoshaPath 这个地址，用来获取秒杀地址，传参为 商品id，在服务端生成随机数（MD5）作为pathId存入缓存，（缓存过期时间60s），然后将这个随机数返回给前端.</li>
<li>获得该pathid后，前端在用这个pathid拼接在Url上作为参数，去请求domiaosha服务</li>
<li>后端接收到这个pathid 参数，并且与缓存中的pathid 比较。如果通过比较，进行秒杀逻辑，如果不通过，抛出业务异常，非法请求。<br><a href="https://www.cnblogs.com/myseries/p/11891132.html" target="_blank" rel="noopener">https://www.cnblogs.com/myseries/p/11891132.html</a></li>
</ul>
<h5 id="秒杀商品详情获取"><a href="#秒杀商品详情获取" class="headerlink" title="秒杀商品详情获取"></a>秒杀商品详情获取</h5><p>热点数据放在 Redis 中。最好写入到jvm 内存一份，jvm 内存中的数据访问速度是最快的</p>
<h4 id="下单"><a href="#下单" class="headerlink" title="下单"></a>下单</h4><p>下单时，会有大并发用户来下单，需要保证商品不超卖</p>
<h5 id="下单请求太多"><a href="#下单请求太多" class="headerlink" title="下单请求太多"></a>下单请求太多</h5><ol>
<li><p>添加校验<br>使用回答问题或者弹出验证码</p>
</li>
<li><p>限流<br>利用令牌桶、计数器算法实现应用级限流。</p>
</li>
</ol>
<p><a href="https://juejin.cn/post/6870396751178629127" target="_blank" rel="noopener">限流算法代码实现例子</a></p>
<h5 id="商品不少卖-高并发下怎么做余额扣减"><a href="#商品不少卖-高并发下怎么做余额扣减" class="headerlink" title="商品不少卖 - 高并发下怎么做余额扣减"></a>商品不少卖 - 高并发下怎么做余额扣减</h5><p>将“实时扣库存”的行为上移到内存 Cache 中操作，内存 Cache 操作成功直接给 Server 返回成功，然后异步落 DB 持久化。</p>
<p>商品总量提前放入 redis 缓存中，让 redis 缓存扣减。redis 单进程，没有资源抢占问题。</p>
<ol>
<li><p>库存移到redis缓存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">对应到代码层面，我们应该如何保证不会超卖呢？我们一般会提前将秒杀商品的信息放到缓存中去。我们可以通过 Redis 对库存进行原子操作。</span><br><span class="line">伪代码如下：</span><br><span class="line">Long count = redisTemplate.increment(key, -1);</span><br><span class="line">if (count &gt;= 0) &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接口层 - 接口幂等</p>
<p> a. 分布式锁：Redis的Redisson。setNX(key)成功，则进行逻辑，然后删除del(key)<br> b. token机制：token机制的核心思想是为每一次操作生成一个唯一性的凭证，也就是token。一个token在操作的每一个阶段只有一次执行权，一旦执行成功则保存执行结果。对重复的请求，返回同一个结果。token机制的应用十分广泛。<br> c. db 唯一索引(建防重表)：业务字段的唯一索性约束，防止重复数据产生<br> d. 乐观锁：业务字段的唯一索性约束，防止重复数据产生<br> e. 悲观锁：没有解决问题。不使用</p>
</li>
</ol>
<p><a href="https://juejin.cn/post/6894624582091669517" target="_blank" rel="noopener">什么是接口的幂等性，如何实现接口幂等性？一文搞定</a><br><a href="https://segmentfault.com/a/1190000039737646" target="_blank" rel="noopener">高并发下如何保证接口的幂等性？</a></p>
<h5 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h5><h6 id="使用缓存，定时写-DB"><a href="#使用缓存，定时写-DB" class="headerlink" title="使用缓存，定时写 DB"></a>使用缓存，定时写 DB</h6><p>先放入redis中，定时写入DB，写入 DB 成功后，删除 redis中缓存</p>
<h6 id="使用MQ-可选"><a href="#使用MQ-可选" class="headerlink" title="使用MQ(可选)"></a>使用MQ(可选)</h6><p>流量削峰用消息队列MQ</p>
<h4 id="高可用-1"><a href="#高可用-1" class="headerlink" title="高可用"></a>高可用</h4><p>大批量请求来袭，服务如何承受</p>
<ol>
<li><p>集群化</p>
</li>
<li><p>限流<br> 限流是从用户访问压力的角度来考虑如何应对系统故障。限流是为了对服务端的接口接受请求的频率进行限制，防止服务挂掉。线程组件：Sentinel 、Hystrix等</p>
<p> ❶ 客户端限流<br> ❷ 服务端限流<br> ❸ 应用层限流：利用令牌桶、计数器算法实现应用级限流。</p>
<p> <a href="https://xie.infoq.cn/article/757d92363268393f497cb2ef3" target="_blank" rel="noopener">https://xie.infoq.cn/article/757d92363268393f497cb2ef3</a></p>
</li>
<li><p>排队<br>你可以把排队看作是限流的一个变种。限流是直接拒绝了用户的请求，而排队则是让用户等待一定的时间（类比现实世界的排队）。</p>
</li>
<li><p>降级<br>降级是从系统功能优先级的角度考虑如何应对系统故障。NOTE:<strong>降级的核心思想就是丢车保帅，优先保证核心业务</strong></p>
</li>
<li><p>熔断<br>熔断和降级是两个比较容易混淆的概念，两者的含义并不相同。<strong>降级的目的是应对系统自身的故障，而熔断的目的是应对当前系统依赖的外部系统或者第三方系统的故障。</strong></p>
<p>熔断可以防止因为秒杀交易影响到其他正常服务的提供:<br>举个例子： 秒杀功能位于服务 A 上，服务 A 上同时还有其他的一些功能比如商品管理。如果服务 A 上的商品管理接口响应非常慢的话，熔断调这个接口，使其他服务不能再请求服务 A上的商品管理这个接口，从而有效避免其他服务被拖慢甚至拖死</p>
</li>
</ol>
<h4 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h4><p>上线之前压力测试是必不可少的。推荐 4个比较常用的性能测试工具：<br>    Jmeter ：Apache JMeter 是 JAVA 开发的性能测试工具。<br>    LoadRunner：一款商业的性能测试工具。<br>    Galtling ：一款基于 Scala 开发的高性能服务器性能测试工具。<br>    ab ：全称为 Apache Bench 。Apache 旗下的一款测试工具，非常实用。</p>
<p>参考：<br><a href="https://xiaozhuanlan.com/topic/4918673052" target="_blank" rel="noopener">https://xiaozhuanlan.com/topic/4918673052</a><br><a href="https://gongfukangee.github.io/2019/06/09/SecondsKill/" target="_blank" rel="noopener">https://gongfukangee.github.io/2019/06/09/SecondsKill/</a></p>
<h3 id="短-URL-系统是怎么设计的？"><a href="#短-URL-系统是怎么设计的？" class="headerlink" title="短 URL 系统是怎么设计的？"></a>短 URL 系统是怎么设计的？</h3><p>其实真正问你的是如下:如何生成，如何存储，如何访问，以及如何高并发生成 与 如何高并发访问</p>
<h4 id="如何生成"><a href="#如何生成" class="headerlink" title="如何生成"></a>如何生成</h4><ol>
<li>使用发号器<br>通过发号策略，给每一个过来的长地址，发一个号即可，小型系统直接用mysql的自增索引就搞定了。如果是大型应用，可以考虑各种分布式key-value系统做发号器。不停的自增就行了。第一个使用这个服务的人得到的短地址是<a href="http://xx.xx/0" target="_blank" rel="noopener">http://xx.xx/0</a> 第二个是 <a href="http://xx.xx/1" target="_blank" rel="noopener">http://xx.xx/1</a> 第11个是 <a href="http://xx.xx/a" target="_blank" rel="noopener">http://xx.xx/a</a> 第依次往后，相当于实现了一个62进制的自增字段即可。为啥用62进制呢，因为 6 位 62 进制数可表示 568 亿的数，应付长链转换绰绰有余<br>参见：<a href="https://www.zhihu.com/question/29270034" target="_blank" rel="noopener">https://www.zhihu.com/question/29270034</a></li>
</ol>
<p>核心：短链接生成算法 ==》核心：全局唯一id生成(即分布式id)，然后将 id 进行 62转码</p>
<p>所以，问题衍生到了如诶生成“全局唯一id生成(即分布式id)”了。<br>方案有Twitter Snowflake，redis redisAtomicLong，mysql自增，javaAddr</p>
<ol start="2">
<li>Hash<br>有重复问题，但可以通过“重复时加入自定义字段” 或 使用布隆过滤器</li>
</ol>
<p>重复时加入自定义字段: 查库，如果发现重复，尾部加入自定义字段，重新hash</p>
<p>使用布隆过滤器: 用所有生成的短网址构建布隆过滤器，当一个新的长链生成短链后，先将此短链在布隆过滤器中进行查找，如果不存在，说明 db 里不存在此短网址，可以保存</p>
<ol start="3">
<li><p>如何保证同一个长地址，每次转出来都是一样的短地址<br>上面的发号原理中，是不判断长地址是否已经转过的。也就是说用拿着百度首页地址来转，我给一个<a href="http://xx.xx/abc" target="_blank" rel="noopener">http://xx.xx/abc</a> 过一段时间你再来转，我还会给你一个 <a href="http://xx.xx/xyz。这看起来挺不好的，但是不好在哪里呢？不好在不是一一对应，而一长对多短。这与我们完美主义的基因不符合，那么除此以外还有什么不对的地方？" target="_blank" rel="noopener">http://xx.xx/xyz。这看起来挺不好的，但是不好在哪里呢？不好在不是一一对应，而一长对多短。这与我们完美主义的基因不符合，那么除此以外还有什么不对的地方？</a><br>有人说它浪费空间，这是对的。同一个长地址，产生多条短地址记录，这明显是浪费空间的。那么我们如何避免空间浪费，有人非常迅速的回答我，建立一个长对短的KV存储即可。嗯，听起来有理，但是。。。这个KV存储本身就是浪费大量空间。所以我们是在用空间换空间，而且貌似是在用大空间换小空间。真的划算吗？这个问题要考虑一下。当然，也不是没有办法解决，我们做不到真正的一一对应，那么打个折扣是不是可以搞定？这个问题的答案太多种，各有各招，我这就不说了。（由于实在太多人纠结这个问题，请见我最下方的更新）</p>
</li>
<li><p>如何保证大并发高可用</p>
</li>
</ol>
<p>(1) 发号器分段<br>上面设计看起来有一个单点，那就是发号器。如果做成分布式的，那么多节点要保持同步加1，多点同时写入，这个嘛，以CAP理论看，是不可能真正做到的。其实这个问题的解决非常简单，我们可以退一步考虑，我们是否可以实现两个发号器，一个发单号，一个发双号，这样就变单点为多点了？依次类推，我们可以实现1000个逻辑发号器，分别发尾号为0到999的号。每发一个号，每个发号器加1000，而不是加1。这些发号器独立工作，互不干扰即可。而且在实现上，也可以先是逻辑的，真的压力变大了，再拆分成独立的物理机器单元。1000个节点，估计对人类来说应该够用了。如果你真的还想更多，理论上也是可以的。</p>
<p>(2) 高并发访问DB查id<br>如果用 Mysql 自增 id 作为短链 ID，在高并发下，db 的写压力会很大，这种情况该怎么办呢。<br>考虑一下，一定要在用到的时候去生成 id 吗，是否可以提前生成这些自增 id ?<br>方案如下：<br>设计一个专门的发号表，每插入一条记录，为短链 id 预留 （主键 id <em> 1000 - 999） 到 (主键 id </em> 1000) 的号段，如下</p>
<p><img src="https://cdn.learnku.com/uploads/images/202012/15/64262/RgOhomEvtg.webp!large" alt="1"></p>
<p>当长链转短链的请求打到某台机器时，先看这台机器是否分配了短链号段，未分配就往发号表插入一条记录，则这台机器将为短链分配范围在 tmp_start_num 到 tmp_end_num 之间的 id。从 tmp_start_num 开始分配，一直分配到 tmp_end_num，如果发号 id 达到了 tmp_end_num，说明这个区间段的 id 已经分配完了，则再往发号表插入一条记录就又获取了一个发号 id 区间。</p>
<p>转自链接：<a href="https://learnku.com/php/t/52596" target="_blank" rel="noopener">https://learnku.com/php/t/52596</a></p>
<h4 id="如何存储"><a href="#如何存储" class="headerlink" title="如何存储"></a>如何存储</h4><p>请求的的长链接作为KEY，生成的短链接作为value存储到DB中。</p>
<ol>
<li>写入时高并发</li>
</ol>
<p>如果用 Mysql 自增 id 作为短链 ID，在高并发下，db 的写压力会很大，这种情况该怎么办呢。考虑一下，一定要在用到的时候去生成 id 吗，是否可以提前生成这些自增 id ?</p>
<p>写入缓存：先存 redis，然后定时批量写入数据库</p>
<p>批量入库</p>
<h4 id="如何访问"><a href="#如何访问" class="headerlink" title="如何访问"></a>如何访问</h4><ol>
<li>跳转用301还是302<br>这也是一个有意思的话题。首先当然考察一个候选人对301和302的理解。浏览器缓存机制的理解。然后是考察他的业务经验。301是永久重定向，302是临时重定向。短地址一经生成就不会变化，所以用301是符合http语义的。同时对服务器压力也会有一定减少。<br>但是如果使用了301，我们就无法统计到短地址被点击的次数了。而这个点击次数是一个非常有意思的大数据分析数据源。能够分析出的东西非常非常多。所以选择302虽然会增加服务器压力，但是我想是一个更好的选择。大概就是这样。</li>
</ol>
<ol start="2">
<li>访问时高并发</li>
</ol>
<p>(1)读写分离<br>这种系统显然，读远大于写。建议可以考虑做读写分离。</p>
<p>(2)引入缓存<br>假设，我们在一个时间。给手机推送短信链接的短信后。显然，后面的一段时间内，对该短链接的请求量会大大提升。没有必要每次都去数据库查询，因此可以引入redis缓存。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>核心：短链接生成算法 ==》核心：全局唯一id生成(即分布式id)</p>
<p>所以，问题衍生到了如诶生成“全局唯一id生成(即分布式id)”了。<br>方案有Twitter Snowflake，redis redisAtomicLong，mysql自增，javaAddr</p>
<p>链接：<a href="https://www.zhihu.com/question/29270034/answer/46446911" target="_blank" rel="noopener">https://www.zhihu.com/question/29270034/answer/46446911</a><br>参考 <a href="https://www.cnblogs.com/myshowtime/p/16316654.html" target="_blank" rel="noopener">https://www.cnblogs.com/myshowtime/p/16316654.html</a><br>整体设计参考：<br><a href="https://learnku.com/php/t/52596" target="_blank" rel="noopener">https://learnku.com/php/t/52596</a><br><a href="https://time.geekbang.org/column/article/80850" target="_blank" rel="noopener">https://time.geekbang.org/column/article/80850</a></p>
<h3 id="如何设计一个RPC系统"><a href="#如何设计一个RPC系统" class="headerlink" title="如何设计一个RPC系统"></a>如何设计一个RPC系统</h3><pre><code>实现一个最基本的 RPC 框架应该至少包括下面几部分:
    注册中心 ：注册中心负责服务地址的注册与查找，相当于目录服务。
    网络传输 ：既然我们要调用远程的方法，就要发送网络请求来传递目标类和方法的信息以及方法的参数等数据到服务提供端。
    序列化和反序列化 ：要在网络传输数据就要涉及到序列化。
    动态代理 ：屏蔽程方法调用的底层细节。
    负载均衡 ： 避免单个服务器响应同一请求，容易造成服务器宕机、崩溃等问题。
    传输协议 ：这个协议是客户端（服务消费方）和服务端（服务提供方）交流的基础。


讲的最好的rpc [RPC框架透彻解析：10个案例，30行代码纯手写一个RPC框架！马士兵]https://www.bilibili.com/video/BV1KG4y167n7?p=3&amp;vd_source=c3e9801497e408c0e02a3ddb59c2d64e

[MyRPCFromZero-version1~6]https://github.com/he2121/MyRPCFromZero

[轻量级分布式 RPC 框架-黄勇-结合spring-文章](https://my.oschina.net/huangyong/blog/361751)
[轻量级分布式 RPC 框架-黄勇-结合spring-代码]https://gitee.com/huangyong/rpc


https://github.com/yaoyuanyy/guide-rpc-framework
https://github.com/Veal98/RPC-FromScratch
https://github.com/junjun888/simple-rpc

https://www.bilibili.com/video/BV1ZF411575U/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=c3e9801497e408c0e02a3ddb59c2d64e
https://github.com/tomstillcoding/Simple-RPC


https://github.com/CN-GuoZiyang/My-RPC-Framework

https://github.com/search?q=My-RPC
</code></pre><h2 id="架构心得"><a href="#架构心得" class="headerlink" title="架构心得"></a>架构心得</h2><pre><code>最后，分享一下做大型应用的架构心得：

    灰度！灰度！灰度！

    监控！监控！监控！

    告警！告警！告警！

    缓存！缓存！缓存！

    限流！熔断！降级！

    低耦合，高内聚！

    避免单点，拥抱无状态！

    评估！评估！评估！

    压测！压测！压测！
</code></pre><p>原文地址：<a href="https://github.com/yaoyuanyy/programing_knowledges/blob/master/java/java%E6%8A%80%E6%9C%AF%E6%A0%88%E7%9F%A5%E8%AF%86%E7%82%B9%E8%8D%89%E9%9B%86.adoc" target="_blank" rel="noopener">java技术栈知识点草集</a></p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://yaoyuanyy.github.io/2021/07/17/java技术栈重要知识点草集/" title="java技术栈重要知识点草集" target="_blank" rel="external">https://yaoyuanyy.github.io/2021/07/17/java技术栈重要知识点草集/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/yaoyuanyy" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/meinv.jpeg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/yaoyuanyy" target="_blank"><span class="text-dark">skyler</span><small class="ml-1x">Web Developer</small></a></h3>
        <div>java后端开发，to B业务，趋于蓝色的性格，喜欢篮球等</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom="">
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2021/09/08/java代码层，jvm层，linux用户层，linux内核层说ReentrantLock与AQS阻塞和唤醒/" title="java代码层，jvm层，linux用户层，linux内核层说ReentrantLock与AQS阻塞和唤醒"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2021/04/16/jvm虚拟机是如何进入spring-boot-loader中JarLauncher-main方法的/" title="jvm虚拟机是如何进入spring-boot-loader中JarLauncher.main方法的"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn " data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">    <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫">
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/wechat_pay.png" alt="扫码支持" title="扫一扫">
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope="" itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/yaoyuanyy" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li>
        
        <li><a href="https://juejin.cn/user/729731449759047/posts" target="_blank" title="Juejin" data-toggle="tooltip" data-placement="top"><i class="icon icon-juejin"></i></a></li>
        
        <li><a href="https://blog.csdn.net/mingliangniwo" target="_blank" title="Csdn" data-toggle="tooltip" data-placement="top"><i class="icon icon-csdn"></i></a></li>
        
        <li><a href="https://yaoyuanyy.github.io" target="_blank" title="Github Pages" data-toggle="tooltip" data-placement="top"><i class="icon icon-github pages"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>
<script src="/js/plugin.min.js"></script>
<script src="/js/application.js"></script>

    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>





   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: 'FA5MfMbhgGSiEPOyVmYfHbR6-gzGzoHsz',
    appKey: '2aAdTrUVOhFxm0uqpBFC1dhv',
    placeholder: 'tell anything',
    avatar: '',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     





    <!-- <script defer type="text/javascript">
(function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'G-WR4XDKYXVY', 'auto');
ga('send', 'pageview');

</script> -->

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-WR4XDKYXVY"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'G-WR4XDKYXVY');
</script>



</body>
</html>